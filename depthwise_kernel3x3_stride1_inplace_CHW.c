/* This file is automatically generated */
/* ----------------------------------------------------------------------
 * Project:      TinyEngine
 * Description:  for sparse in-place 3x3 depth-wise convolution (HWC->CHW->HWC)
 * Target ISA:  ARMv7E-M
 * Author: wmchen@mit.edu
 * -------------------------------------------------------------------- */
#include "arm_nnsupportfunctions.h" //TODO: remove this in the future for self-contained
#include "tinyengine_function.h"
#include "arm_math.h"
#include "img2col_element.h"
#include "arm_nnsupportfunctions.h"
#include <string.h>

q7_t* mat_mult_unloop18_s8_s16_stride(const q7_t* input_a,
    const q15_t* input_b,
    const uint16_t output_ch,
    const int32_t* out_shift,
    const int32_t* out_mult,
    const int32_t out_offset,
    const int16_t activation_min,
    const int16_t activation_max,
    const uint16_t num_col_a,
    const int32_t* const output_bias,
    const int stride,
    q7_t* out_0,
    q15_t* kbuf)
{
    /* set up the second output pointers */
    q7_t* out_1 = out_0 + output_ch * stride;
    const int32_t* bias = output_bias;
    uint16_t row_count = output_ch / 2;
    const q15_t* ksrc = &kbuf[0];
    /* this loop over rows in A */
    while (row_count)
    {
        /* setup pointers for B */
        const q15_t* ip_b0 = input_b;
        const q15_t* ip_b1 = ip_b0 + num_col_a;
        const q31_t* ip31_b0 = ip_b0;
        const q31_t* ip31_b1 = ip_b1;

        /* align the second pointer for A */
        const q15_t* ksrc2 = ksrc + 18;
        q31_t* ksrc_31 = ksrc;
        q31_t* ksrc2_31 = ksrc2;

        /* Init accumulator with bias for channel N and N + 1 */
        q31_t ch_0_out_0 = *bias;
        q31_t ch_0_out_1 = *bias++;
        q31_t ch_1_out_0 = *bias;
        q31_t ch_1_out_1 = *bias++;

        //------------------4
        q31_t a01, a02, a11, a12;
        q31_t b0 = arm_nn_read_q15x2_ia(&ip_b0);
        q31_t b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[0], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[0], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[0], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[0], b1, ch_1_out_1);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[1], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[1], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[1], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[1], b1, ch_1_out_1);

        //------------------8
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[2], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[2], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[2], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[2], b1, ch_1_out_1);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[3], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[3], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[3], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[3], b1, ch_1_out_1);

        //------------------12
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[4], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[4], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[4], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[4], b1, ch_1_out_1);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[5], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[5], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[5], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[5], b1, ch_1_out_1);

        //------------------16
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);
        ch_0_out_0 = __SMLAD(ksrc_31[6], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[6], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[6], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[6], b1, ch_1_out_1);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[7], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[7], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[7], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[7], b1, ch_1_out_1);

        //------------------17,18
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);
        ch_0_out_0 = __SMLAD(ksrc_31[12], b0, ch_0_out_0);
        ch_0_out_1 = __SMLAD(ksrc_31[12], b1, ch_0_out_1);
        ch_1_out_0 = __SMLAD(ksrc2_31[12], b0, ch_1_out_0);
        ch_1_out_1 = __SMLAD(ksrc2_31[12], b1, ch_1_out_1);

        ch_0_out_0 = arm_nn_requantize(ch_0_out_0, *out_mult, *out_shift);
        ch_0_out_0 += out_offset;
        ch_0_out_0 = MAX(ch_0_out_0, activation_min);
        ch_0_out_0 = MIN(ch_0_out_0, activation_max);
        *out_0++ = (q7_t)ch_0_out_0;

        ch_0_out_1 = arm_nn_requantize(ch_0_out_1, *out_mult, *out_shift);
        ch_0_out_1 += out_offset;
        ch_0_out_1 = MAX(ch_0_out_1, activation_min);
        ch_0_out_1 = MIN(ch_0_out_1, activation_max);
        *out_1++ = (q7_t)ch_0_out_1;
        out_mult++;
        out_shift++;

        ch_1_out_0 = arm_nn_requantize(ch_1_out_0, *out_mult, *out_shift);
        ch_1_out_0 += out_offset;
        ch_1_out_0 = MAX(ch_1_out_0, activation_min);
        ch_1_out_0 = MIN(ch_1_out_0, activation_max);
        *out_0++ = (q7_t)ch_1_out_0;

        ch_1_out_1 = arm_nn_requantize(ch_1_out_1, *out_mult, *out_shift);
        ch_1_out_1 += out_offset;
        ch_1_out_1 = MAX(ch_1_out_1, activation_min);
        ch_1_out_1 = MIN(ch_1_out_1, activation_max);
        *out_1++ = (q7_t)ch_1_out_1;
        out_mult++;
        out_shift++;

        /* skip row */
        ksrc += 36;
        row_count--;
    }

    /* return the new output pointer with offset */
    return out_1 + stride * output_ch;
}

void depthwise_kernel3x3_stride1_inplace_kernel_CHW(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset);
tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW(
		q7_t *input,
		const uint16_t input_x, const uint16_t input_y, const uint16_t input_ch,
		const q7_t *kernel,
		const int32_t *bias,
		const int32_t *biasR,
                const int32_t *output_shift,
				const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min, const int32_t output_activation_max,
				q7_t *output,
                const uint16_t output_x, const uint16_t output_y, const uint16_t output_ch,
				q15_t *runtime_buf, q7_t pad_value)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }

    //middle regions: left and right regions
    for(i = 0; i < input_y; i++){
        *cols_8b++ = PAD8;//left
        cols_8b += input_x; //skip middle
        *cols_8b++ = PAD8;//right
    }

    //bottom region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
        cols_8b = (q7_t*)(cols_8b_start + 1 * (input_x) + 2); //skip 1 rows
        src = input;
        for(i = 0; i < input_y; i++){
            cols_8b += 1;//skip front
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b += 1;//skip end
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        input++;
    }
}


tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_FStore(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t pad)
{

    uint16_t c,i,j, sx;
    q7_t* cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;

    q7_t* r_store_loc = input+ (input_y - pad) * input_ch;
    q7_t* b_store_loc = input + (input_y - pad) * input_x * input_ch;
    uint16_t store_size = pad * input_ch;

    for (sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 1; i++){
        *cols_8b++ = PAD8;
    }

    //middle regions: left and right regions
    for(i = 0; i < input_y; i++){
        *cols_8b++ = PAD8;//left
        cols_8b += input_x + 1; //skip middle
    }


    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
        cols_8b = (q7_t*) (cols_8b_start + input_x + 1);
        src = input;
        for(i = 0; i < input_y; i++){
            cols_8b += 1;//skip front
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_FStore_RLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t* r_load_start,
				q7_t pad)
{

    uint16_t c,i,j, sx;
    q7_t* cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
	q7_t* r_load = r_load_start;
    q7_t* r_store_loc = input+ (input_y - pad) *input_ch;
    q7_t* b_store_loc = input + (input_y - pad) * input_x * input_ch;
    uint16_t store_size = pad * input_ch;

    for (sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + pad; i++){
        *cols_8b++ = PAD8;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
        cols_8b = (q7_t*)(cols_8b_start + input_x + pad); //skip 1 rows
        src = input;
        for(i = 0; i < input_y; i++){
            *cols_8b++ = *r_load;
            r_load += input_ch;
            *cols_8b++ = *r_load;
            r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_RStore_FLoad(q7_t* input, const uint16_t input_x, const uint16_t input_y,
    const uint16_t input_ch, const q7_t* kernel, const int32_t* bias, const int32_t* biasR,
    const int32_t* output_shift, const int32_t* output_mult,
    const int32_t output_offset, const int32_t input_offset,
    const int32_t output_activation_min,
    const int32_t output_activation_max, q7_t* output,
    const uint16_t output_x, const uint16_t output_y,
    const uint16_t output_ch, q15_t* runtime_buf, q7_t pad_value,
    q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
    q7_t* r_store,
    q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
    q7_t pad)
{

    uint16_t c, i, j;
    q7_t* cols_8b_start = (q7_t*)runtime_buf;
    q7_t* cols_8b = (q7_t*)cols_8b_start + (pad + input_x) * (input_y - 1);
    uint16_t sx, sy;
    q7_t* r_store_loc = input + (input_x - pad) * input_ch;
    uint16_t store_size = pad * input_ch;
    q7_t* r_load = r_load_start;
    q7_t* b_load = b_load_start;
    q7_t* br_load = br_load_start;

    for (sx = 0; sx < input_y; sx++) {
        memcpy(r_store, r_store_loc, store_size);
        r_store_loc += input_ch * input_x;
        r_store += store_size;
    }


    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value


    for (i = 0; i < input_x + pad; i++) {
        *cols_8b++ = PAD8;
    }

    const q7_t* src;
    const q7_t* ksrc = kernel;

    for (c = 0; c < input_ch; c++) {
        r_load = r_load_start;
        b_load = b_load_start;
        br_load = br_load_start;
        cols_8b = (q7_t*)cols_8b_start;
        for (sx = 0; sx < pad; sx++) {
            *cols_8b++ = *br_load;
            br_load += input_ch;
            *cols_8b++ = *br_load;
            br_load += input_ch;
            for (i = 0; i < input_x; i++) {
                *cols_8b++ = *b_load;
                b_load += input_ch;
            }
        }
        src = input;
        for (i = 0; i < input_y; i++) {
            for (j = 0; j < input_x; j++) {
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }

        q7_t* inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out, output_offset, output_activation_min, output_activation_max, cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        b_load_start++;
        br_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_BStore_RLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* b_store,
				q7_t* r_load_start,
				q7_t pad)
{

    uint16_t c,i,j, sx;
    q7_t* cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start + pad + input_x;
	q7_t* r_load = r_load_start;
    q7_t* b_store_loc = input + (input_y - pad) * input_x * input_ch;
    uint16_t store_size = pad * input_ch;

    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value


    for(i = 0; i < input_y; i++){
    	*cols_8b = PAD8;
        cols_8b += input_x + pad + 1;
    }

    for(i = 0; i < pad + input_x + 1; i++) {
    	*++cols_8b += PAD8;
    }
    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
        cols_8b = (q7_t*)cols_8b_start;
        src = input;
        for(i = 0; i < input_y; i++){
            *cols_8b++ = *r_load;
            r_load += input_ch;
            *cols_8b++ = *r_load;
            r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_FStore_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
	q7_t* r_load = r_load_start;
	q7_t* b_load = b_load_start;
	q7_t* br_load = br_load_start;
    q7_t* r_store_loc = input+ (input_x - pad) * input_ch;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);

    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    /*
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }

    //middle regions: left and right regions
    for(i = 0; i < input_y; i++){
        *cols_8b++ = PAD8;//left
        cols_8b += input_x; //skip middle
        *cols_8b++ = PAD8;//right
    }

    //bottom region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }
	*/
    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
    	b_load = b_load_start;
    	br_load = br_load_start;
    	cols_8b = (q7_t*)cols_8b_start;
    	for (sx = 0; sx < pad; sx++) {
    		*cols_8b++ = *br_load;
    		br_load += input_ch;
       		*cols_8b++ = *br_load;
            br_load += input_ch;
            for (i = 0; i < input_x; i++) {
            	*cols_8b++ = *b_load;
            	b_load += input_ch;
            }
    	}
        src = input;
        for(i = 0; i < input_y; i++){
        	*cols_8b++ = *r_load;
        	r_load += input_ch;
        	*cols_8b++ = *r_load;
        	r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        b_load_start++;
        br_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_RStore_BLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store,
				q7_t* b_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
	q7_t* b_load = b_load_start;
    q7_t* r_store_loc = input+ (input_x - pad) * input_ch;
    uint16_t store_size = pad * input_ch;
    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }

    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    for (i = 0; i < input_y + pad; i++) {
    	*cols_8b++ = PAD8;
    	cols_8b += input_x + 1 + pad;
    }

    for(i=0; i < input_x + pad + 1; i++) {
    	*++cols_8b = PAD8;
    }
    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	b_load = b_load_start;
        cols_8b = (q7_t*)(cols_8b_start + 1); //skip 1 rows
        for (sx = 0; sx < pad; sx++) {
			for (i = 0; i < input_x; i++) {
				*cols_8b++ = *b_load;
				b_load += input_ch;
			}
			cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b += 1;//skip end
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        b_load_start++;
        input++;
    }
}


tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_FStore_BLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t* b_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
	q7_t* b_load = b_load_start;
    q7_t* r_store_loc = input+ (input_x - pad) * input_ch;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    for (i = 0; i < input_y + pad; i++) {
    	*cols_8b = PAD8;
    	cols_8b += input_x + pad + 1;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	b_load = b_load_start;
        cols_8b = (q7_t*)(cols_8b_start + 1); //skip 1 rows
        for (sx = 0; sx < pad; sx++) {
			for (i = 0; i < input_x; i++) {
				*cols_8b++ = *b_load;
				b_load += input_ch;
			}
			cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b += 1;//skip end
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        b_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_BStore_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* b_store,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start + pad + input_x;
    uint16_t sx, sy;
	q7_t* br_load = br_load_start;
	q7_t* b_load = b_load_start;
	q7_t* r_load = r_load_start;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    for (i = 0; i < input_y + pad; i++) {
    	*cols_8b = PAD8;
    	cols_8b += input_x + pad + 1;;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	br_load = br_load_start;
    	b_load = b_load_start;
    	r_load = r_load_start;
        cols_8b = (q7_t*)cols_8b_start; //skip 1 rows
        for (sx = 0; sx < pad; sx++) {
			*cols_8b++ = *br_load;
			br_load += input_ch;
			*cols_8b++ = *br_load;
			br_load += input_ch;
			for (i = 0; i < input_x; i++) {
				*cols_8b++ = *b_load;
				b_load += input_ch;
			}
			cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
        	*cols_8b++ = r_load;
        	r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        br_load_start++;
        b_load_start++;
        r_load_start++;
        input++;
    }
}



tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start + pad + input_x;;
    uint16_t sx, sy;
    uint16_t store_size = pad * input_ch;
	q7_t* r_load = r_load_start;
	q7_t* b_load = b_load_start;
	q7_t* br_load = br_load_start;
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    for (i = 0; i < input_y + pad; i++) {
    	*cols_8b = PAD8;
    	cols_8b += input_x + pad + 1;
    }

    for (i = 0; i < input_x + 1 + pad; i++) {
    	*++cols_8b = PAD8;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
    	b_load = b_load_start;
    	br_load = br_load_start;

        cols_8b = (q7_t*)cols_8b_start;
        for (sx = 0; sx < pad; sx++) {
        	*cols_8b++ = *br_load;
        	br_load += input_ch;
        	*cols_8b++ = *br_load;
        	br_load += input_ch;
        	for(i = 0; i < input_x; i++) {
        		*cols_8b++ = b_load;
        		b_load += input_ch;
        	}
        	cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
        	*cols_8b++ = *r_load;
        	r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b++;
        }

        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        b_load_start++;
        br_load_start++;
        input++;
    }
}




void depthwise_kernel3x3_stride1_inplace_kernel_CHW(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset)
{
    #define STRIDE 1
    int i, j;
    /* MACs for each output */
    q31_t ch_bias = bias[0] + biasR[0];
    for (i = 0; i < output_y; i++) {
        for (j = 0; j < output_x / 2; j++) {
            q7_t *cols_8b = cols_8b_iterptr;

            q31_t sum0 = bias[0] + biasR[0];
            q31_t sum1 = bias[0] + biasR[0];

            /* computation */
            sum0 += cols_8b[0]*ksrc[0];
            sum1 += cols_8b[1]*ksrc[0];
            sum0 += cols_8b[1]*ksrc[1];
            sum1 += cols_8b[2]*ksrc[1];
            sum0 += cols_8b[2]*ksrc[2];
            sum1 += cols_8b[3]*ksrc[2];
            cols_8b += column_x +2;
            //cols_8b -= 2;
            sum0 += cols_8b[0]*ksrc[3];
            sum1 += cols_8b[1]*ksrc[3];
            sum0 += cols_8b[1]*ksrc[4];
            sum1 += cols_8b[2]*ksrc[4];
            sum0 += cols_8b[2]*ksrc[5];
            sum1 += cols_8b[3]*ksrc[5];
            cols_8b += column_x + 2;
            //cols_8b -= 2;
            sum0 += cols_8b[0]*ksrc[6];
            sum1 += cols_8b[1]*ksrc[6];
            sum0 += cols_8b[1]*ksrc[7];
            sum1 += cols_8b[2]*ksrc[7];
            sum0 += cols_8b[2]*ksrc[8];
            sum1 += cols_8b[3]*ksrc[8];

            /* requantize */
            sum0 = arm_nn_requantize(sum0 , *multiplier, *shift);
            sum0 += output_offset;
            sum0 = MAX(sum0, activation_min);
            sum0 = MIN(sum0, activation_max);
            output[(i * output_x + j * 2) * channel_offset] = sum0;
            sum1 = arm_nn_requantize(sum1 , *multiplier, *shift);
            sum1 += output_offset;
            sum1 = MAX(sum1, activation_min);
            sum1 = MIN(sum1, activation_max);
            output[(i * output_x + (j * 2 + 1)) * channel_offset] = sum1;

            cols_8b_iterptr += STRIDE * 2;
        }
        if (output_x & 1) {
            q7_t * cols_8b = cols_8b_iterptr;
            q31_t sum =bias[0] + biasR[0];
            sum += cols_8b[0]*ksrc[0];
            sum += cols_8b[1]*ksrc[1];
            sum += cols_8b[2]*ksrc[2];
            cols_8b += column_x + 2 ;
            sum += cols_8b[0]*ksrc[3];
            sum += cols_8b[1]*ksrc[4];
            sum += cols_8b[2]*ksrc[5];
            cols_8b += column_x + 2;
            sum += cols_8b[0]*ksrc[6];
            sum += cols_8b[1]*ksrc[7];
            sum += cols_8b[2]*ksrc[8];

            sum = arm_nn_requantize(sum  , *multiplier, *shift);
            sum += output_offset;
            sum = MAX(sum, activation_min);
            sum = MIN(sum, activation_max);
            output[(i * output_x + output_x - 1) * channel_offset] = sum;

            cols_8b_iterptr += STRIDE;
        }
        cols_8b_iterptr += 1 * 2;
    }
}

void depthwise_kernel3x3_stride1_inplace_kernel_CHW_PSK(
    const uint16_t output_y, const uint16_t output_x,
    const int32_t* bias, const int32_t* biasR, const q7_t* ksrc, const int32_t* multiplier,
    const int32_t* shift, q7_t* output, const int32_t output_offset,
    const int32_t activation_min, const int32_t activation_max,
    q7_t* cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t* fold_weight);
tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_PSK(q7_t* input, const uint16_t input_x, const uint16_t input_y,
    const uint16_t input_ch, const q7_t* kernel, const int32_t* bias, const int32_t* biasR,
    const int32_t* output_shift, const int32_t* output_mult,
    const int32_t output_offset, const int32_t input_offset,
    const int32_t output_activation_min,
    const int32_t output_activation_max, q7_t* output,
    const uint16_t output_x, const uint16_t output_y,
    const uint16_t output_ch, q15_t* runtime_buf, q7_t pad_value, const q7_t* fold_weight)
{

    uint16_t c, i, j;
    q7_t* cols_8b_start = (q7_t*)runtime_buf;
    q7_t* cols_8b = (q7_t*)cols_8b_start;

    const q7_t* src;
    const q7_t* ksrc = kernel;

    for (c = 0; c < input_ch; c++) {
        cols_8b = cols_8b_start;
        src = input;
        for (j = 0; j < input_y; j++) {
            for (i = 0; i < input_x; i++) {
                *cols_8b++ = *src;
                src += input_ch;
            }
        }
        q7_t* inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW_PSK(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out, output_offset, output_activation_min, output_activation_max, cols_8b_start, input_x, input_ch, (const q7_t*)fold_weight);
        ksrc += 9;
        fold_weight += 40;
        input++;
    }

}
void depthwise_kernel3x3_stride1_inplace_kernel_CHW_PSK(
    const uint16_t output_y, const uint16_t output_x,
    const int32_t* bias, const int32_t* biasR, const q7_t* ksrc, const int32_t* multiplier,
    const int32_t* shift, q7_t* output, const int32_t output_offset,
    const int32_t activation_min, const int32_t activation_max,
    q7_t* cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t* fold_weight)
{
#define STRIDE 1
#define STRIDE 1
    int y = 0;
    int x = 0;

    q7_t* cols_8b_left_start = cols_8b_iterptr;
    q7_t* cols_8b_start = cols_8b_iterptr;
    q31_t ch_bias = bias[0] + biasR[0];
    q7_t* cols_8b_bot_iterptr = cols_8b_start + column_x * (column_x - 2);

    q7_t* cols_8b_left = cols_8b_start;
    q7_t* cols_8b_right = cols_8b_start + column_x - 2;
    q31_t sum0 = ch_bias;
    q31_t sum1 = ch_bias;

    sum0 += cols_8b_left[0] * fold_weight[0];
    sum0 += cols_8b_left[1] * fold_weight[1];
    sum0 += cols_8b_right[2] * fold_weight[2];
    sum0 += cols_8b_right[3] * fold_weight[3];
    sum1 += cols_8b_right[0] * fold_weight[4];
    sum1 += cols_8b_right[1] * fold_weight[5];


    sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
    sum0 += output_offset;
    sum0 = MAX(sum0, activation_min);
    sum0 = MIN(sum0, activation_max);
    cols_8b_right += column_x;
    sum1 += cols_8b_right[0] * fold_weight[6];
    sum1 += cols_8b_right[1] * fold_weight[7];


    sum0 = ch_bias;
    sum1 = ch_bias;
    sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
    sum1 += output_offset;
    sum1 = MAX(sum1, activation_min);
    sum1 = MIN(sum1, activation_max);
    output[0] = sum0;
    output[(output_x - 1) * channel_offset] = sum1;

    cols_8b_left = cols_8b_bot_iterptr;
    cols_8b_right = cols_8b_bot_iterptr + column_x - 2;

    sum0 += cols_8b_left[0] * fold_weight[8];
    sum0 += cols_8b_left[1] * fold_weight[9];
    sum0 += cols_8b_right[2] * fold_weight[10];
    sum0 += cols_8b_right[3] * fold_weight[11];
    sum1 += cols_8b_right[0] * fold_weight[12];
    sum1 += cols_8b_right[1] * fold_weight[13];

    sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
    sum0 += output_offset;
    sum0 = MAX(sum0, activation_min);
    sum0 = MIN(sum0, activation_max);

    cols_8b_right += column_x;
    sum1 += cols_8b_right[0] * fold_weight[14];
    sum1 += cols_8b_right[1] * fold_weight[15];



    sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
    sum1 += output_offset;
    sum1 = MAX(sum1, activation_min);
    sum1 = MIN(sum1, activation_max);
    output[((output_y - 1) * output_x) * channel_offset] = sum0;
    output[((output_y - 1) * output_x + output_x - 1) * channel_offset] = sum1;



    for (x = 1; x < output_x / 2; ++x) {
        q7_t* cols_8b = cols_8b_iterptr;
        q7_t* cols_8b_bot = cols_8b_bot_iterptr;
        q31_t sumB0 = ch_bias;
        q31_t sumB1 = ch_bias;
        q31_t sum0 = ch_bias;
        q31_t sum1 = ch_bias;

        sumB0 += cols_8b_bot[0] * fold_weight[22];
        sumB1 += cols_8b_bot[1] * fold_weight[22];
        sumB0 += cols_8b_bot[1] * fold_weight[23];
        sumB1 += cols_8b_bot[2] * fold_weight[23];
        sumB0 += cols_8b_bot[2] * fold_weight[24];
        sumB1 += cols_8b_bot[3] * fold_weight[24];


        cols_8b_bot += column_x;

        sumB0 += cols_8b_bot[0] * fold_weight[25];
        sumB1 += cols_8b_bot[1] * fold_weight[25];
        sumB0 += cols_8b_bot[1] * fold_weight[26];
        sumB1 += cols_8b_bot[2] * fold_weight[26];
        sumB0 += cols_8b_bot[2] * fold_weight[27];
        sumB1 += cols_8b_bot[3] * fold_weight[27];

        cols_8b_iterptr += 1;
        cols_8b_bot_iterptr += 1;

        sumB0 = arm_nn_requantize(sumB0, *multiplier, *shift);
        sumB0 += output_offset;
        sumB0 = MAX(sumB0, activation_min);
        sumB0 = MIN(sumB0, activation_max);
        sumB1 = arm_nn_requantize(sumB1, *multiplier, *shift);
        sumB1 += output_offset;
        sumB1 = MAX(sumB1, activation_min);
        sumB1 = MIN(sumB1, activation_max);
        output[((output_y - 1) * output_x + x * 2 - 1) * channel_offset] = sumB0;
        output[((output_y - 1) * output_x + x * 2) * channel_offset] = sumB1;

        cols_8b_iterptr += 1;
        sum0 += cols_8b[0] * fold_weight[16];
        sum1 += cols_8b[1] * fold_weight[16];
        sum0 += cols_8b[1] * fold_weight[17];
        sum1 += cols_8b[2] * fold_weight[17];
        sum0 += cols_8b[2] * fold_weight[18];
        sum1 += cols_8b[3] * fold_weight[18];
        //cols_8b_iterptr += 1;
        cols_8b += column_x;
        sum0 += cols_8b[0] * fold_weight[19];
        sum1 += cols_8b[1] * fold_weight[19];
        sum0 += cols_8b[1] * fold_weight[20];
        sum1 += cols_8b[2] * fold_weight[20];
        sum0 += cols_8b[2] * fold_weight[21];
        sum1 += cols_8b[3] * fold_weight[21];


        sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
        sum0 += output_offset;
        sum0 = MAX(sum0, activation_min);
        sum0 = MIN(sum0, activation_max);
        sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
        sum1 += output_offset;
        sum1 = MAX(sum1, activation_min);
        sum1 = MIN(sum1, activation_max);
        output[(2 * x - 1) * channel_offset] = sum0;
        output[(2 * x) * channel_offset] = sum1;


        cols_8b_bot_iterptr += 1;

    }
    if (output_x & 1) {
        q7_t* cols_8b = cols_8b_iterptr;
        q7_t* cols_8b_bot = cols_8b_bot_iterptr;
        q31_t sum = ch_bias;
        q31_t sumB = ch_bias;
        sum += cols_8b[0] * fold_weight[16];
        sum += cols_8b[1] * fold_weight[17];
        sum += cols_8b[2] * fold_weight[18];
        cols_8b += column_x;
        sum += cols_8b[0] * fold_weight[19];
        sum += cols_8b[1] * fold_weight[20];
        sum += cols_8b[2] * fold_weight[21];
        sumB += cols_8b_bot[0] * fold_weight[22];
        sumB += cols_8b_bot[1] * fold_weight[23];
        sumB += cols_8b_bot[2] * fold_weight[24];
        cols_8b_bot += column_x;
        sumB += cols_8b_bot[0] * fold_weight[25];
        sumB += cols_8b_bot[1] * fold_weight[26];
        sumB += cols_8b_bot[2] * fold_weight[27];
        sum = arm_nn_requantize(sum, *multiplier, *shift);
        sum += output_offset;
        sum = MAX(sum, activation_min);
        sum = MIN(sum, activation_max);
        cols_8b_iterptr += 1;
        sumB = arm_nn_requantize(sumB, *multiplier, *shift);
        sumB += output_offset;
        sumB = MAX(sumB, activation_min);
        sumB = MIN(sumB, activation_max);
        output[(output_x - 2) * channel_offset] = sum;
        output[((output_y - 1) * output_x - 2) * channel_offset] = sumB;
        cols_8b_bot_iterptr += 1;
    }

    q7_t* cols_8b_left_iterptr = cols_8b_left_start;
    q7_t* cols_8b_right_iterptr = cols_8b_iterptr;

    for (y = 1; y < output_y / 2; ++y) {
        q7_t* cols_left_8b = cols_8b_left_iterptr;
        q7_t* cols_right_8b = cols_8b_right_iterptr;
        q31_t sumL0 = ch_bias;
        q31_t sumL1 = ch_bias;
        q31_t sumR0 = ch_bias;
        q31_t sumR1 = ch_bias;
        //DWT->FOLDCNT = 0;
        sumL0 += cols_left_8b[0] * fold_weight[28];
        sumL0 += cols_left_8b[1] * fold_weight[29];


        cols_left_8b += column_x;
        cols_right_8b += column_x;

        sumL0 += cols_left_8b[0] * fold_weight[30];
        sumL0 += cols_left_8b[1] * fold_weight[31];



        sumL1 += cols_left_8b[0] * fold_weight[28];
        sumL1 += cols_left_8b[1] * fold_weight[29];
        sumL1 += cols_right_8b[2] * fold_weight[30];
        sumL1 += cols_right_8b[3] * fold_weight[31];

        sumR0 += cols_left_8b[-2] * fold_weight[34];
        sumR0 += cols_left_8b[-1] * fold_weight[35];

        sumR1 += cols_right_8b[0] * fold_weight[34];
        sumR1 += cols_right_8b[1] * fold_weight[35];

        sumL0 += cols_right_8b[2] * fold_weight[32];
        sumL0 += cols_right_8b[3] * fold_weight[33];
        cols_left_8b += 2 * column_x;
        sumL1 += cols_left_8b[0] * fold_weight[32];
        sumL1 += cols_left_8b[1] * fold_weight[33];


        cols_8b_left_iterptr += column_x;
        cols_8b_right_iterptr += column_x;

        sumL0 = arm_nn_requantize(sumL0, *multiplier, *shift);
        sumL0 += output_offset;
        sumL0 = MAX(sumL0, activation_min);
        sumL0 = MIN(sumL0, activation_max);
        sumL1 = arm_nn_requantize(sumL1, *multiplier, *shift);
        sumL1 += output_offset;
        sumL1 = MAX(sumL1, activation_min);
        sumL1 = MIN(sumL1, activation_max);
        output[(2 * y - 1) * output_x * channel_offset] = sumL0;
        output[2 * y * output_x * channel_offset] = sumL1;

        sumR0 += cols_right_8b[0] * fold_weight[36];
        sumR0 += cols_right_8b[1] * fold_weight[37];


        cols_right_8b += 2 * column_x;

        sumR1 += cols_left_8b[-2] * fold_weight[36];
        sumR1 += cols_left_8b[-1] * fold_weight[37];


        sumR0 += cols_left_8b[-2] * fold_weight[38];
        sumR0 += cols_left_8b[-1] * fold_weight[39];


        sumR1 += cols_right_8b[0] * fold_weight[38];
        sumR1 += cols_right_8b[1] * fold_weight[39];

        sumR0 = arm_nn_requantize(sumR0, *multiplier, *shift);
        sumR0 += output_offset;
        sumR0 = MAX(sumR0, activation_min);
        sumR0 = MIN(sumR0, activation_max);






        sumR1 = arm_nn_requantize(sumR1, *multiplier, *shift);
        sumR1 += output_offset;
        sumR1 = MAX(sumR1, activation_min);
        sumR1 = MIN(sumR1, activation_max);
        output[((2 * y - 1) * output_x + output_x - 1) * channel_offset] = sumR0;
        output[((2 * y) * output_x + output_x - 1) * channel_offset] = sumR1;

        cols_8b_left_iterptr += column_x;
        cols_8b_right_iterptr += column_x;
    }
    if (output_y & 1) {
        q7_t* cols_right_8b = cols_8b_right_iterptr;
        q31_t sumR = ch_bias;
        q31_t sumL = ch_bias;

        sumR += cols_right_8b[0] * fold_weight[34];
        sumR += cols_right_8b[1] * fold_weight[35];

        sumL += cols_right_8b[2] * fold_weight[30];
        sumL += cols_right_8b[3] * fold_weight[31];
        cols_right_8b += column_x;

        sumR += cols_right_8b[0] * fold_weight[36];
        sumR += cols_right_8b[1] * fold_weight[37];

        sumL += cols_right_8b[2] * fold_weight[32];
        sumL += cols_right_8b[3] * fold_weight[33];

        //cols_right_8b += column_x;
        sumR += cols_right_8b[column_x] * fold_weight[38];
        sumR += cols_right_8b[column_x + 1] * fold_weight[39];

        sumL += cols_8b_right_iterptr[-column_x + 2] * fold_weight[28];
        sumL += cols_8b_right_iterptr[-column_x + 3] * fold_weight[29];


        sumL = arm_nn_requantize(sumL, *multiplier, *shift);
        sumL += output_offset;
        sumL = MAX(sumL, activation_min);
        sumL = MIN(sumL, activation_max);

        sumR = arm_nn_requantize(sumR, *multiplier, *shift);
        sumR += output_offset;
        sumR = MAX(sumR, activation_min);
        sumR = MIN(sumR, activation_max);
        output[(output_y * output_x - 1) * channel_offset] = sumL;
        output[((output_y - 1) * output_x + output_x - 1) * channel_offset] = sumR;




    }
    cols_8b_iterptr = cols_8b_start;
    for (y = 1; y < output_y - 1; y++) {
        for (x = 1; x < output_x / 2; x++) {
            q7_t* cols_8b = cols_8b_iterptr;
            q31_t sum0 = ch_bias;
            q31_t sum1 = ch_bias;

            sum0 += cols_8b[0] * ksrc[0];
            sum1 += cols_8b[1] * ksrc[0];
            sum0 += cols_8b[1] * ksrc[1];
            sum1 += cols_8b[2] * ksrc[1];
            sum0 += cols_8b[2] * ksrc[2];
            sum1 += cols_8b[3] * ksrc[2];

            cols_8b += column_x;
            sum0 += cols_8b[0] * ksrc[3];
            sum1 += cols_8b[1] * ksrc[3];
            sum0 += cols_8b[1] * ksrc[4];
            sum1 += cols_8b[2] * ksrc[4];
            sum0 += cols_8b[2] * ksrc[5];
            sum1 += cols_8b[3] * ksrc[5];

            cols_8b += column_x;
            sum0 += cols_8b[0] * ksrc[6];
            sum1 += cols_8b[1] * ksrc[6];
            sum0 += cols_8b[1] * ksrc[7];
            sum1 += cols_8b[2] * ksrc[7];
            sum0 += cols_8b[2] * ksrc[8];
            sum1 += cols_8b[3] * ksrc[8];



            sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
            sum0 += output_offset;
            sum0 = MAX(sum0, activation_min);
            sum0 = MIN(sum0, activation_max);
            sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
            sum1 += output_offset;
            sum1 = MAX(sum1, activation_min);
            sum1 = MIN(sum1, activation_max);


            output[(y * output_x + x * 2 - 1) * channel_offset] = sum0;
            output[(y * output_x + x * 2) * channel_offset] = sum1;

            cols_8b_iterptr += 1 * 2;
        }
        if (output_x & 1) {
            q7_t* cols_8b = cols_8b_iterptr;
            q31_t sum = ch_bias;
            sum += cols_8b[0] * ksrc[0];
            sum += cols_8b[1] * ksrc[1];
            sum += cols_8b[2] * ksrc[2];
            cols_8b += column_x;
            sum += cols_8b[0] * ksrc[3];
            sum += cols_8b[1] * ksrc[4];
            sum += cols_8b[2] * ksrc[5];

            cols_8b += column_x;
            sum += cols_8b[0] * ksrc[6];
            sum += cols_8b[1] * ksrc[7];
            sum += cols_8b[2] * ksrc[8];
            sum = arm_nn_requantize(sum, *multiplier, *shift);
            sum += output_offset;
            sum = MAX(sum, activation_min);
            sum = MIN(sum, activation_max);
            output[(y * output_x + output_x - 2) * channel_offset] = sum;

            cols_8b_iterptr += 1;
        }
        cols_8b_iterptr += 2;
    }

}

q7_t* arm_nn_mat_mult_kernel3_input3_s8_s16_stride(const q7_t* input_a,
    const q15_t* input_b,
    const uint16_t output_ch,
    const int32_t* out_shift,
    const int32_t* out_mult,
    const int32_t out_offset,
    const int16_t activation_min,
    const int16_t activation_max,
    const uint16_t num_col_a,
    const int32_t* const output_bias,
    const int stride,
    q7_t* out_0,
    q15_t* kbuf);
tinyengine_status convolve_s8_kernel3_inputch3_stride2_pad1_PSK(const q7_t* input, const uint16_t input_x, const uint16_t input_y,
    const uint16_t input_ch, const q7_t* kernel, const int32_t* bias,
    const int32_t* output_shift, const int32_t* output_mult,
    const int32_t output_offset, const int32_t input_offset,
    const int32_t output_activation_min,
    const int32_t output_activation_max, q7_t* output,
    const uint16_t output_x, const uint16_t output_y,
    const uint16_t output_ch, q15_t* runtime_buf, q15_t* kbuf, q7_t pad_value, const q7_t* fold_weight) {
    const int kernel_y = 3;
    const int kernel_x = 3;

    int16_t i_out_y, i_out_x, i_ker_y, i_ker_x;

    /* Generate two columns from the input tensor a GEMM computation */
    q15_t* two_column_buf = runtime_buf;
    q7_t* out = output;
    int stride = 1;
    q15_t pad16 = pad_value;
    const int16_t inoff16 = input_offset;
    q15_t pad_out = pad16 + inoff16;
    q31_t pad_out_q15x2 = __PKHBT(pad_out, pad_out, 16);
    q31_t offset_q15x2 = __PKHBT(inoff16, inoff16, 16);
    // zero skipping
    const q7_t* ip_a0 = kernel;
    const q7_t* ip_tb0 = fold_weight;
    const q7_t* ip_bb0 = fold_weight + 288;

    // Memory 
    // [top border (Cout x 2 x 3 x 3 [18] (Cin)) | main kernel (Cout x 3 x 3 x 3) [27] | bot kernel (Cout x 2 x 3 x 3) [18] ]
    // --> 21 x 3 --> 63
    //DWT->CYCCNT = 0; start = DWT->CYCCNT;
    for (int i = 0; i < output_ch; i += 2) {
        q15_t* dst1 = &kbuf[i * 27]; //each q31_t store 2 elements
        q15_t* dst2 = dst1 + 27;

        const q7_t* ip_a1 = ip_a0 + 27;
        const q7_t* ip_tb1 = ip_tb0 + 18;
        const q7_t* ip_bb1 = ip_bb0 + 18;

        q31_t* dst1_31 = dst1;
        q31_t* dst2_31 = dst2;


        //18 for each output_ch for top kernel
        ip_tb0 = read_and_pad(ip_tb0, &dst1_31[0], &dst1_31[1]);
        ip_tb1 = read_and_pad(ip_tb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_tb0 = read_and_pad(ip_tb0, &dst1_31[0], &dst1_31[1]);
        ip_tb1 = read_and_pad(ip_tb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_tb0 = read_and_pad(ip_tb0, &dst1_31[0], &dst1_31[1]);
        ip_tb1 = read_and_pad(ip_tb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_tb0 = read_and_pad(ip_tb0, &dst1_31[0], &dst1_31[1]);
        ip_tb1 = read_and_pad(ip_tb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        dst1 = dst1_31;
        dst2 = dst2_31;
        dst1[0] = *ip_tb0++;
        dst1[1] = *ip_tb0++;
        dst2[0] = *ip_tb1++;
        dst2[1] = *ip_tb1++;

        dst1_31 = dst1 + 2;
        dst2_31 = dst2 + 2;

        //27 for each output_ch for mid kernel
        ip_a0 = read_and_pad(ip_a0, &dst1_31[0], &dst1_31[1]);
        ip_a1 = read_and_pad(ip_a1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_a0 = read_and_pad(ip_a0, &dst1_31[0], &dst1_31[1]);
        ip_a1 = read_and_pad(ip_a1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_a0 = read_and_pad(ip_a0, &dst1_31[0], &dst1_31[1]);
        ip_a1 = read_and_pad(ip_a1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_a0 = read_and_pad(ip_a0, &dst1_31[0], &dst1_31[1]);
        ip_a1 = read_and_pad(ip_a1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_a0 = read_and_pad(ip_a0, &dst1_31[0], &dst1_31[1]);
        ip_a1 = read_and_pad(ip_a1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_a0 = read_and_pad(ip_a0, &dst1_31[0], &dst1_31[1]);
        ip_a1 = read_and_pad(ip_a1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;
        //25, 26, 27
        dst1 = dst1_31;
        dst2 = dst2_31;
        dst1[0] = *ip_a0++;
        dst1[1] = *ip_a0++;
        dst1[2] = *ip_a0++;
        dst2[0] = *ip_a1++;
        dst2[1] = *ip_a1++;
        dst2[2] = *ip_a1++;

        dst1_31 = dst1 + 3;
        dst2_31 = dst2 + 3;

        //18 for each output_ch for top kernel
        ip_bb0 = read_and_pad(ip_bb0, &dst1_31[0], &dst1_31[1]);
        ip_bb1 = read_and_pad(ip_bb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_bb0 = read_and_pad(ip_bb0, &dst1_31[0], &dst1_31[1]);
        ip_bb1 = read_and_pad(ip_bb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_bb0 = read_and_pad(ip_bb0, &dst1_31[0], &dst1_31[1]);
        ip_bb1 = read_and_pad(ip_bb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        ip_bb0 = read_and_pad(ip_bb0, &dst1_31[0], &dst1_31[1]);
        ip_bb1 = read_and_pad(ip_bb1, &dst2_31[0], &dst2_31[1]);
        dst1_31 += 2;
        dst2_31 += 2;

        dst1 = dst1_31;
        dst2 = dst2_31;
        dst1[0] = *ip_tb0++;
        dst1[1] = *ip_tb0++;
        dst2[0] = *ip_tb1++;
        dst2[1] = *ip_tb1++;

        /* skip row */
        ip_a0 += 27;

        ip_tb0 += 18;
        ip_bb0 += 18;
    }
    //end = DWT->CYCCNT;sprintf(buf, "Kernel Copy %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
    int input_row_offset = 3 * input_x;
    q8_t* src = input;
    q8_t* src1 = src + input_row_offset;
    q8_t* src2;
    q8_t* src3;

    const q15_t* col_buffer = two_column_buf;
    q15_t* dst = col_buffer;
    q15_t* dst2 = dst + 6;
    q15_t* dst3;


    q31_t in_q7x4;
    q31_t in_q15x2_1;
    q31_t in_q15x2_2;
    q31_t out_q15x2_1;
    q31_t out_q15x2_2;

    // Top Left
    // 2 * 3 + 2 * 3 --> 12
    // 6 = 4 + 2;

    q7_q15_offset_ele(src, dst);
    *dst++ = *src++ + input_offset;
    *dst++ = *src++ + input_offset;

    q7_q15_offset_ele(src2, dst2);
    *dst2++ = *src2++ + input_offset;
    *dst2++ = *src2++ + input_offset;


    const q7_t* ker_a = fold_weight + 576;
    int i;
    for (i = 0; i < output_ch; i++) {
        q31_t sum = bias[i];
        const q15_t* ip_as_col = runtime_buf;
        uint16_t col_count = input_ch;
        while (col_count) {
            q31_t ker_a1, ker_a2;
            q31_t ip_b1, ip_b2;

            ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

            ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
            sum = __SMLAD(ker_a1, ip_b1, sum);
            ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
            sum = __SMLAD(ker_a2, ip_b2, sum);

            col_count--;
        }

        col_count = input_ch * kernel_y * kernel_x & 0x3;
        while (col_count) {
            q7_t ker_a1 = *ker_a++;
            q15_t ip_b1 = *ip_as_col++;
            sum += ker_a1 * ip_b1;
            col_count--;
        }

        sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
        sum += output_offset;
        sum = MAX(sum, output_activation_min);
        sum = MIN(sum, output_activation_max);
        *out++ = (q7_t)sum;
    }

    two_column_buf = runtime_buf;

    //end = DWT->CYCCNT;sprintf(buf, "TOP TOP %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
    for (i_out_x = 1; i_out_x < output_x; i_out_x++) {
        const int16_t base_idx_x = (i_out_x * 2 - 1) * input_ch;
        src = input + base_idx_x;
        src2 = src + input_row_offset;
        q15_t* dst = two_column_buf;
        q15_t* dst2 = dst + 6;
        // Top read
        // 3 * 3 + 3 * 3 --> 18
        //4 * 2 + 1 = 9
        q7_q15_offset_ele(src, dst)
            q7_q15_offset_ele(src, dst)
            * dst++ = *src++ + input_offset;
        //4 * 2 + 1 = 9
        q7_q15_offset_ele(src2, dst2)
            q7_q15_offset_ele(src2, dst2)
            * dst2++ = *src2++ + input_offset;

        two_column_buf += 18;
        if (two_column_buf == runtime_buf + 36) {
            out = mat_mult_unloop18_s8_s16(kernel,
                runtime_buf, output_ch, output_shift, output_mult,
                output_offset, output_activation_min, output_activation_max,
                input_ch * 6, bias, out, kbuf);

            two_column_buf = runtime_buf;
        }
    }
    if ((output_y & 1) == (input_y & 1)) {
        const q7_t* ker_a = kernel;
        int i;

        for (i = 0; i < output_ch; i++) {
            /* Load the accumulator with bias first */
            q31_t sum = bias[i];

            /* Point to the beginning of the im2col buffer where the input is available as a rearranged column */
            const q15_t* ip_as_col = runtime_buf;

            /* 4 multiply and accumulates are done in one loop. */
            // thinking point
            uint16_t col_count = (input_ch * 3) >> 1;

            while (col_count) {
                q31_t ker_a1, ker_a2;
                q31_t ip_b1, ip_b2;

                ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a1, ip_b1, sum);
                ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a2, ip_b2, sum);

                col_count--;
            }
            /* Handle left over mac */
            col_count = (input_ch * 2 * 3) & 0x1;
            while (col_count) {
                q7_t ker_a1 = *ker_a++;
                q15_t ip_b1 = *ip_as_col++;
                sum += ker_a1 * ip_b1;
                col_count--;
            }

            sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
            sum += output_offset;
            sum = MAX(sum, output_activation_min);
            sum = MIN(sum, output_activation_max);
            *out++ = (q7_t)sum;
        }
    }

    two_column_buf = runtime_buf;
    kbuf += 3 * 6 * 12;
    //


    //end = DWT->CYCCNT;sprintf(buf, "CONV3x3_TOP %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
    // Top compute
    //DWT->CYCCNT = 0; start = DWT->CYCCNT;
    for (i_out_y = 1; i_out_y < output_y; i_out_y++) {
        const int16_t base_idx_y = (i_out_y * 2 - 1) * input_row_offset;
        src = input + base_idx_y;
        src2 = src + input_row_offset;
        src3 = src2 + input_row_offset;
        dst = two_column_buf;
        dst2 = dst + 6;
        dst3 = dst2 + 6;
        // Top read
        // 3 * 3 + 3 * 3 --> 18
        //4 * 2 + 1 = 9
        q7_q15_offset_ele(src, dst)
            * dst++ = *src++ + input_offset;
        *dst++ = *src++ + input_offset;

        //4 * 2 + 1 = 9
        q7_q15_offset_ele(src2, dst2)
            * dst2++ = *src2++ + input_offset;
        *dst2++ = *src2++ + input_offset;

        q7_q15_offset_ele(src3, dst3)
            * dst3++ = *src3++ + input_offset;
        *dst3++ = *src3++ + input_offset;

        two_column_buf += 18;
        if (two_column_buf == runtime_buf + 36) {
            out = mat_mult_unloop18_s8_s16_stride(kernel,
                runtime_buf, output_ch, output_shift, output_mult,
                output_offset, output_activation_min, output_activation_max,
                input_ch * 6, bias, output_x, out, kbuf);

            two_column_buf = runtime_buf;
        }
    }
    if ((output_y & 1) == (input_y & 1)) {
        const q7_t* ker_a = kernel;
        int i;

        for (i = 0; i < output_ch; i++) {
            /* Load the accumulator with bias first */
            q31_t sum = bias[i];

            /* Point to the beginning of the im2col buffer where the input is available as a rearranged column */
            const q15_t* ip_as_col = runtime_buf;

            /* 4 multiply and accumulates are done in one loop. */
            // thinking point
            uint16_t col_count = (input_ch * 3) >> 1;

            while (col_count) {
                q31_t ker_a1, ker_a2;
                q31_t ip_b1, ip_b2;

                ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a1, ip_b1, sum);
                ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a2, ip_b2, sum);

                col_count--;
            }
            /* Handle left over mac */
            col_count = (input_ch * 2 * 3) & 0x1;
            while (col_count) {
                q7_t ker_a1 = *ker_a++;
                q15_t ip_b1 = *ip_as_col++;
                sum += ker_a1 * ip_b1;
                col_count--;
            }

            sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
            sum += output_offset;
            sum = MAX(sum, output_activation_min);
            sum = MIN(sum, output_activation_max);
            *out++ = (q7_t)sum;
        }
    }
    two_column_buf = runtime_buf;
    out -= (output_y * output_x - output_x + 1) * output_ch;
    //end = DWT->CYCCNT;sprintf(buf, "CONV3x3_LEFT %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
    /*
    // topright
    if(input_x & 1) {
        const q15_t *col_buffer = two_column_buf;
        src = input + (input_x - 1) * input_ch;
        dst = col_buffer;
        dst2 = dst + 6;

        // Top Left
        // 2 * 3 + 2 * 3 --> 12
        q7_q15_offset_ele(src, dst);
        *dst++ = *src++ + input_offset;
        *dst++ = *src++ + input_offset;

        q7_q15_offset_ele(src2, dst2);
        *dst2++ = *src2++ + input_offset;
        *dst2++ = *src2++ + input_offset;

        const q7_t *ker_a = fold_weight + 768;
        for(i = 0; i < output_ch; i++) {
            q31_t sum = bias[i];
            const q15_t *ip_as_col = runtime_buf;
            uint16_t col_count = input_ch;
            while(col_count) {
                q31_t ker_a1, ker_a2;
                q31_t ip_b1, ip_b2;

                ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a1, ip_b1, sum);
                ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a2, ip_b2, sum);

                col_count--;
            }
            col_count = input_ch * kernel_y * kernel_x & 0x3;
            while (col_count) {
                q7_t ker_a1 = *ker_a++;
                q15_t ip_b1 = *ip_as_col++;
                sum += ker_a1 * ip_b1;
                col_count--;
            }

            sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
            sum += output_offset;
            sum = MAX(sum, output_activation_min);
            sum = MIN(sum, output_activation_max);
            *out++ = (q7_t) sum;
        }
    }
    */
    kbuf += 3 * 6 * 12;
    for (i_out_y = 1; i_out_y < output_y; i_out_y++) {
        const int16_t base_idx_y = (i_out_y * 2) - 1;

        /*
                const q15_t *col_buffer = two_column_buf;
                src = input + (base_idx_y * input_x) * input_ch;
                src2 = src1 + input_row_offset;
                src3 = src2 + input_row_offset;
                dst = col_buffer;
                dst2 = dst + 6;
                dst3 = dst2 + 6;

                // Top Left
                // 2 * 3 + 2  * 3 + 2 * 3-->  18
                q7_q15_offset_ele(src, dst)
                *dst++ = *src++ + input_offset;
                *dst++ = *src++ + input_offset;

                q7_q15_offset_ele(src2, dst2)
                *dst2++ = *src2++ + input_offset;
                *dst2++ = *src2++ + input_offset;

                q7_q15_offset_ele(src3, dst3)
                *dst3++ = *src3++ + input_offset;
                *dst3++ = *src3++ + input_offset;

                const q7_t *ker_a = fold_weight + 960;
                for(i = 0; i < output_ch; i++) {
                    q31_t sum = bias[i];
                    const q15_t *ip_as_col = runtime_buf;
                    uint16_t col_count = input_ch * 3 >> 1;
                    while(col_count) {
                        q31_t ker_a1, ker_a2;
                        q31_t ip_b1, ip_b2;

                        ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                        ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                        sum = __SMLAD(ker_a1, ip_b1, sum);
                        ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                        sum = __SMLAD(ker_a2, ip_b2, sum);

                        col_count--;
                    }
                    col_count = input_ch * kernel_y * kernel_x & 0x3;
                    while (col_count) {
                        q7_t ker_a1 = *ker_a++;
                        q15_t ip_b1 = *ip_as_col++;
                        sum += ker_a1 * ip_b1;
                        col_count--;
                    }

                    sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
                    sum += output_offset;
                    sum = MAX(sum, output_activation_min);
                    sum = MIN(sum, output_activation_max);
                    *out++ = (q7_t) sum;
                }
        */
        for (i_out_x = 1; i_out_x < output_x; i_out_x++) {

            const int16_t base_idx_x = (i_out_x * 2) - 1;
            const q15_t* col_buffer = two_column_buf;
            dst = col_buffer;
            dst2 = dst + 9;
            dst3 = dst2 + 9;
            src = input + (base_idx_y * input_x + base_idx_x) * input_ch;
            src2 = src + input_row_offset;
            src3 = src2 + input_row_offset;


            //4 * 2 = 8
            q7_q15_offset_ele(src, dst)
                q7_q15_offset_ele(src, dst)
                * dst++ = *src++ + input_offset;
            //
            q7_q15_offset_ele(src2, dst2)
                q7_q15_offset_ele(src2, dst2)
                * dst2++ = *src2++ + input_offset;
            //
            q7_q15_offset_ele(src3, dst3)
                q7_q15_offset_ele(src3, dst3)
                * dst3++ = *src3++ + input_offset;

            two_column_buf += 27;

            if (two_column_buf == runtime_buf + 2 * 27) {

                out = arm_nn_mat_mult_kernel3_input3_s8_s16_stride(kernel,
                    runtime_buf, output_ch, output_shift, output_mult,
                    output_offset, output_activation_min, output_activation_max,
                    input_ch * kernel_y * kernel_x, bias, stride, out, kbuf);

                two_column_buf = runtime_buf;
                stride = 1;
            }
        }
        stride = 2;
    }

    if (two_column_buf != runtime_buf) {
        const q7_t* ker_a = kernel;
        int i;

        for (i = 0; i < output_ch; i++) {
            /* Load the accumulator with bias first */
            q31_t sum = bias[i];

            /* Point to the beginning of the im2col buffer where the input is available as a rearranged column */
            const q15_t* ip_as_col = runtime_buf;

            /* 4 multiply and accumulates are done in one loop. */
            uint16_t col_count = (input_ch * kernel_y * kernel_x) >> 2;

            while (col_count) {
                q31_t ker_a1, ker_a2;
                q31_t ip_b1, ip_b2;

                ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a1, ip_b1, sum);
                ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a2, ip_b2, sum);

                col_count--;
            }
            /* Handle left over mac */
            col_count = input_ch * kernel_y * kernel_x & 0x3;
            while (col_count) {
                q7_t ker_a1 = *ker_a++;
                q15_t ip_b1 = *ip_as_col++;
                sum += ker_a1 * ip_b1;
                col_count--;
            }

            sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
            sum += output_offset;
            sum = MAX(sum, output_activation_min);
            sum = MIN(sum, output_activation_max);
            *out++ = (q7_t)sum;
        }
    }
    //end = DWT->CYCCNT;sprintf(buf, "CONV3x3_MID %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
}
/*
if (output_x & 1) {
    const q15_t *col_buffer = two_column_buf;
    src = input + (base_idx_y * input_x +  input_x - 1) * input_ch;
    src2 = src1 + input_row_offset;
    src3 = src2 + input_row_offset;
    dst = col_buffer;
    dst2 = dst + 6;
    dst3 = dst2 + 6;

    // Top Left
    // 2 * 3 + 2 * 3 + 2 * 3-->  18
    q7_q15_offset_ele(src, dst)
    *dst++ = *src++ + input_offset;
    *dst++ = *src++ + input_offset;

    q7_q15_offset_ele(src2, dst2)
    *dst2++ = *src2++ + input_offset;
    *dst2++ = *src2++ + input_offset;

    q7_q15_offset_ele(src3, dst3)
    *dst3++ = *src3++ + input_offset;
    *dst3++ = *src3++ + input_offset;

    const q7_t *ker_a = fold_weight + 1248;
    for(i = 0; i < output_ch; i++) {
        q31_t sum = bias[i];
        const q15_t *ip_as_col = runtime_buf;
        uint16_t col_count = input_ch * 3 >> 1;
        while(col_count) {
            q31_t ker_a1, ker_a2;
            q31_t ip_b1, ip_b2;

            ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

            ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
            sum = __SMLAD(ker_a1, ip_b1, sum);
            ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
            sum = __SMLAD(ker_a2, ip_b2, sum);

            col_count--;
        }
        col_count = input_ch * kernel_y * kernel_x & 0x3;
        while (col_count) {
            q7_t ker_a1 = *ker_a++;
            q15_t ip_b1 = *ip_as_col++;
            sum += ker_a1 * ip_b1;
            col_count--;
        }

        sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
        sum += output_offset;
        sum = MAX(sum, output_activation_min);
        sum = MIN(sum, output_activation_max);
        *out++ = (q7_t) sum;
    }
}
}
*/

/*
    if(input_y & 1) {
        const int16_t base_idx_y = (input_y - 2) * input_x;
        const q15_t *col_buffer = two_column_buf;

        src = input	+ base_idx_y * input_x * input_ch;
        src2 = src + input_row_offset;

        q15_t* dst = col_buffer;
        q15_t* dst2 = dst + 6;

        q7_q15_offset_ele(src, dst)
        *dst++ = *src++ + input_offset;
        *dst++ = *src++ + input_offset;

        q7_q15_offset_ele(src2, dst2)
        *dst2++ = *src2++ + input_offset;
        *dst2++ = *src2++ + input_offset;

        const q7_t *ker_a = fold_weight + 1536;
        for(i = 0; i < output_ch; i++) {
            q31_t sum = bias[i];
            const q15_t *ip_as_col = runtime_buf;
            uint16_t col_count = input_ch;
            while(col_count) {
                q31_t ker_a1, ker_a2;
                q31_t ip_b1, ip_b2;

                ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a1, ip_b1, sum);
                ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a2, ip_b2, sum);

                col_count--;
            }
            //col_count = input_ch * kernel_y * kernel_x & 0x3;
            //while (col_count) {
            //	q7_t ker_a1 = *ker_a++;
            //	q15_t ip_b1 = *ip_as_col++;
            //	sum += ker_a1 * ip_b1;
            //	col_count--;
            //}

            sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
            sum += output_offset;
            sum = MAX(sum, output_activation_min);
            sum = MIN(sum, output_activation_max);
            *out++ = (q7_t) sum;
        }

        for(i_out_x = 1; i_out_x < output_x - (output_x & 1); i_out_x++) {
            const int16_t base_idx_x = (i_out_x * 2) - 1;
            const q15_t *col_buffer = two_column_buf;
            src = input	+ (base_idx_y * input_x + base_idx_x) * input_ch;
            src2 = src + input_row_offset;

            dst = col_buffer;
            dst2 = dst + 9;
            //3 * 3 + 3 * 3 --> 18
            q7_q15_offset_ele(src, dst)
            q7_q15_offset_ele(src, dst)
            *dst++ = *src++ + input_offset;
            //
            q7_q15_offset_ele(src2, dst2)
            q7_q15_offset_ele(src2, dst2)
            *dst2++ = *src2++ + input_offset;
            //
            q7_q15_offset_ele(src3, dst3)
            q7_q15_offset_ele(src3, dst3)
            *dst3++ = *src3++ + input_offset;

            two_column_buf += 18;
            if (two_column_buf == runtime_buf + 2 * 18) {

                out = mat_mult_unloop18_s8_s16(kernel,
                        runtime_buf, output_ch, output_shift, output_mult,
                        output_offset, output_activation_min, output_activation_max,
                        input_ch * 2 * 3, bias, out, kbuf + 16 * 45);
                two_column_buf = runtime_buf;
            }
        }


        /*
        col_buffer = two_column_buf;
        src = input + (input_x - 1) * input_ch;
        dst = col_buffer;
        dst2 = dst + 6;

        // Top Left
        // 2 * 3 + 2 * 3 --> 12
        q7_q15_offset_ele(src, dst);
        *dst++ = *src++ + input_offset;
        *dst++ = *src++ + input_offset;

        q7_q15_offset_ele(src2, dst2);
        *dst2++ = *src2++ + input_offset;
        *dst2++ = *src2++ + input_offset;

        ker_a = fold_weight + 1728;
        for(i = 0; i < output_ch; i++) {
            q31_t sum = bias[i];
            const q15_t *ip_as_col = runtime_buf;
            uint16_t col_count = input_ch;
            while(col_count) {
                q31_t ker_a1, ker_a2;
                q31_t ip_b1, ip_b2;

                ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

                ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a1, ip_b1, sum);
                ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
                sum = __SMLAD(ker_a2, ip_b2, sum);

                col_count--;
            }
            col_count = input_ch;
            //while (col_count) {
            //	q7_t ker_a1 = *ker_a++;
            //	q15_t ip_b1 = *ip_as_col++;
            //	sum += ker_a1 * ip_b1;
            //	col_count--;
            //}
            sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
            sum += output_offset;
            sum = MAX(sum, output_activation_min);
            sum = MIN(sum, output_activation_max);
            *out++ = (q7_t) sum;
        }
    }
    */

q7_t* arm_nn_mat_mult_kernel3_input3_s8_s16_stride(const q7_t* input_a,
    const q15_t* input_b,
    const uint16_t output_ch,
    const int32_t* out_shift,
    const int32_t* out_mult,
    const int32_t out_offset,
    const int16_t activation_min,
    const int16_t activation_max,
    const uint16_t num_col_a,
    const int32_t* const output_bias,
    const int stride,
    q7_t* out_0,
    q15_t* kbuf)
{
    /* set up the second output pointers */
    q7_t* out_3 = out_0 + output_ch * stride;
    const int32_t* bias = output_bias;

    uint16_t row_count = output_ch / 2;
    const q15_t* ksrc = &kbuf[0];
    /* this loop over rows in A */
    while (row_count)
    {
        /* setup pointers for B */
        const q15_t* ip_b0 = input_b;
        const q15_t* ip_b1 = ip_b0 + num_col_a;
        const q31_t* ip31_b0 = ip_b0;
        const q31_t* ip31_b1 = ip_b1;

        /* align the second pointer for A */
        const q15_t* ksrc2 = ksrc + 27;
        q31_t* ksrc_31 = ksrc;
        q31_t* ksrc2_31 = ksrc2;

        /* Init accumulator with bias for channel N and N + 1 */
        q31_t ch_0_out_0 = *bias;
        q31_t ch_0_out_3 = *bias++;
        q31_t ch_1_out_0 = *bias;
        q31_t ch_1_out_3 = *bias++;

        //------------------4
        q31_t a01, a02, a11, a12;
        q31_t b0 = arm_nn_read_q15x2_ia(&ip_b0);
        q31_t b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[0], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[0], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[0], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[0], b1, ch_1_out_3);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[1], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[1], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[1], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[1], b1, ch_1_out_3);

        //------------------8
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[2], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[2], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[2], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[2], b1, ch_1_out_3);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[3], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[3], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[3], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[3], b1, ch_1_out_3);

        //------------------12
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[4], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[4], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[4], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[4], b1, ch_1_out_3);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[5], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[5], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[5], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[5], b1, ch_1_out_3);

        //------------------16
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);
        ch_0_out_0 = __SMLAD(ksrc_31[6], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[6], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[6], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[6], b1, ch_1_out_3);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[7], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[7], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[7], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[7], b1, ch_1_out_3);

        //------------------20
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);
        ch_0_out_0 = __SMLAD(ksrc_31[8], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[8], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[8], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[8], b1, ch_1_out_3);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[9], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[9], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[9], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[9], b1, ch_1_out_3);

        //------------------24
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);
        ch_0_out_0 = __SMLAD(ksrc_31[10], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[10], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[10], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[10], b1, ch_1_out_3);

        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);

        ch_0_out_0 = __SMLAD(ksrc_31[11], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[11], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[11], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[11], b1, ch_1_out_3);

        //------------------25,26,27
        b0 = arm_nn_read_q15x2_ia(&ip_b0);
        b1 = arm_nn_read_q15x2_ia(&ip_b1);
        ch_0_out_0 = __SMLAD(ksrc_31[12], b0, ch_0_out_0);
        ch_0_out_3 = __SMLAD(ksrc_31[12], b1, ch_0_out_3);
        ch_1_out_0 = __SMLAD(ksrc2_31[12], b0, ch_1_out_0);
        ch_1_out_3 = __SMLAD(ksrc2_31[12], b1, ch_1_out_3);
        q15_t _b0 = *ip_b0++;
        q15_t _b1 = *ip_b1++;

        ch_0_out_0 += ksrc[26] * _b0;
        ch_0_out_3 += ksrc[26] * _b1;
        ch_1_out_0 += ksrc2[26] * _b0;
        ch_1_out_3 += ksrc2[26] * _b1;

        ch_0_out_0 = arm_nn_requantize(ch_0_out_0, *out_mult, *out_shift);
        ch_0_out_0 += out_offset;
        ch_0_out_0 = MAX(ch_0_out_0, activation_min);
        ch_0_out_0 = MIN(ch_0_out_0, activation_max);
        *out_0++ = (q7_t)ch_0_out_0;

        ch_0_out_3 = arm_nn_requantize(ch_0_out_3, *out_mult, *out_shift);
        ch_0_out_3 += out_offset;
        ch_0_out_3 = MAX(ch_0_out_3, activation_min);
        ch_0_out_3 = MIN(ch_0_out_3, activation_max);
        *out_3++ = (q7_t)ch_0_out_3;
        out_mult++;
        out_shift++;

        ch_1_out_0 = arm_nn_requantize(ch_1_out_0, *out_mult, *out_shift);
        ch_1_out_0 += out_offset;
        ch_1_out_0 = MAX(ch_1_out_0, activation_min);
        ch_1_out_0 = MIN(ch_1_out_0, activation_max);
        *out_0++ = (q7_t)ch_1_out_0;

        ch_1_out_3 = arm_nn_requantize(ch_1_out_3, *out_mult, *out_shift);
        ch_1_out_3 += out_offset;
        ch_1_out_3 = MAX(ch_1_out_3, activation_min);
        ch_1_out_3 = MIN(ch_1_out_3, activation_max);
        *out_3++ = (q7_t)ch_1_out_3;
        out_mult++;
        out_shift++;

        /* skip row */
        ksrc += 54;
        row_count--;
    }



    /* return the new output pointer with offset */
    return out_3 + output_ch * stride;
}
