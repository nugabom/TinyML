/* This file is automatically generated */
/* ----------------------------------------------------------------------
 * Project:      TinyEngine
 * Description:  for sparse in-place 3x3 depth-wise convolution (HWC->CHW->HWC)
 * Target ISA:  ARMv7E-M
 * Author: wmchen@mit.edu
 * -------------------------------------------------------------------- */
#include "arm_nnsupportfunctions.h" //TODO: remove this in the future for self-contained
#include "tinyengine_function.h"
#include "stm32f7xx_hal.h"
int start, end;
char buf[100];
void depthwise_kernel3x3_stride2_inplace_kernel_CHW(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset);
tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;

    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }

    //middle regions: left and right regions
    for(i = 0; i < input_y; i++){
        *cols_8b++ = PAD8;//left
        cols_8b += input_x; //skip middle
        *cols_8b++ = PAD8;//right
    }

    //bottom region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
        cols_8b = (q7_t*)(cols_8b_start + 1 * (input_x) + 2); //skip 1 rows
        src = input;
        for(i = 0; i < input_y; i++){
            cols_8b += 1;//skip front
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b += 1;//skip end
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        input++;
    }

}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_FStore(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t pad)
{

    uint16_t c,i,j, sx;
    q7_t* cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;

    q7_t* r_store_loc = input + (input_y - pad) * input_ch;
    q7_t* b_store_loc = input + (input_y - pad) * input_x * input_ch;
    uint16_t store_size = pad * input_ch;

    for (sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 1; i++){
        *cols_8b++ = PAD8;
    }

    //middle regions: left and right regions
    for(i = 0; i < input_y; i++){
        *cols_8b++ = PAD8;//left
        cols_8b += input_x + 1; //skip middle
    }


    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
        cols_8b = (q7_t*) (cols_8b_start + input_x + 1);
        src = input;
        for(i = 0; i < input_y; i++){
            cols_8b += 1;//skip front
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_FStore_RLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t* r_load_start,
				q7_t pad)
{

    uint16_t c,i,j, sx;
    q7_t* cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
	q7_t* r_load = r_load_start;
    q7_t* r_store_loc = input + (input_y - pad) *input_ch;
    q7_t* b_store_loc = input + (input_y - pad) * input_x * input_ch;
    uint16_t store_size = pad * input_ch;

    for (sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + pad; i++){
        *cols_8b++ = PAD8;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
        cols_8b = (q7_t*)(cols_8b_start + input_x + pad); //skip 1 rows
        src = input;
        for(i = 0; i < input_y; i++){
            *cols_8b++ = *r_load;
            r_load += input_ch;
            *cols_8b++ = *r_load;
            r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_BStore_RLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* b_store,
				q7_t* r_load_start,
				q7_t pad)
{

    uint16_t c,i,j, sx;
    q7_t* cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start + pad + input_x;
	q7_t* r_load = r_load_start;
    q7_t* b_store_loc = input + (input_y - pad) * input_x * input_ch;
    uint16_t store_size = pad * input_ch;

    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value


    for(i = 0; i < input_y; i++){
    	*cols_8b = PAD8;
        cols_8b += input_x + pad + 1;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
        cols_8b = (q7_t*)cols_8b_start;
        src = input;
        for(i = 0; i < input_y; i++){
            *cols_8b++ = *r_load;
            r_load += input_ch;
            *cols_8b++ = *r_load;
            r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_FStore_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
	q7_t* r_load = r_load_start;
	q7_t* b_load = b_load_start;
	q7_t* br_load = br_load_start;
    q7_t* r_store_loc = input + (input_x - pad) * input_ch;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);

    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    /*
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }

    //middle regions: left and right regions
    for(i = 0; i < input_y; i++){
        *cols_8b++ = PAD8;//left
        cols_8b += input_x; //skip middle
        *cols_8b++ = PAD8;//right
    }

    //bottom region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value
    for(i = 0; i < input_x + 2; i++){
        *cols_8b++ = PAD8;
    }
	*/
    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
    	b_load = b_load_start;
    	br_load = br_load_start;
    	cols_8b = (q7_t*)cols_8b_start;
        src = input;
    	for (sx = 0; sx < pad; sx++) {
    		*cols_8b++ = *br_load;
    		br_load += input_ch;
       		*cols_8b++ = *br_load;
            br_load += input_ch;
            for (i = 0; i < input_x; i++) {
            	*cols_8b++ = *b_load;
            	b_load += input_ch;
            }
    	}
        src = input;
        for(i = 0; i < input_y; i++){
        	*cols_8b++ = *r_load;
        	r_load += input_ch;
        	*cols_8b++ = *r_load;
        	r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        b_load_start++;
        br_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_RStore_BLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store,
				q7_t* b_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
	q7_t* b_load = b_load_start;
    q7_t* r_store_loc = input + (input_x - pad) * input_ch;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }

    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    for (i = 0; i < input_y + pad; i++) {
    	*cols_8b++ = PAD8;
    	cols_8b += input_x + 1 + pad;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	b_load = b_load_start;
        cols_8b = (q7_t*)(cols_8b_start + 1); //skip 1 rows
        for (sx = 0; sx < pad; sx++) {
			for (i = 0; i < input_x; i++) {
				*cols_8b++ = *b_load;
				b_load += input_ch;
			}
			cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b += 1;//skip end
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        b_load_start++;
        input++;
    }
}


tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_FStore_BLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store, q7_t* b_store, q7_t* br_store,
				q7_t* b_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
	q7_t* b_load = b_load_start;
    q7_t* r_store_loc = input + (input_x - pad) * input_ch;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	if (sx >= input_y - pad) {
    		memcpy(br_store, r_store_loc, store_size);
    		br_store += store_size;
    	}
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    for (i = 0; i < input_y + pad; i++) {
    	*cols_8b = PAD8;
    	cols_8b += input_x + pad + 1;
    }

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
        src = input;
    	b_load = b_load_start;
        cols_8b = (q7_t*)(cols_8b_start + 1); //skip 1 rows
        for (sx = 0; sx < pad; sx++) {
			for (i = 0; i < input_x; i++) {
				*cols_8b++ = *b_load;
				b_load += input_ch;
			}
			cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b += 1;//skip end
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        b_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_BStore_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* b_store,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    uint16_t sx;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
	q7_t* br_load = br_load_start;
	q7_t* b_load = b_load_start;
	q7_t* r_load = r_load_start;
    q7_t* b_store_loc = input+ (input_y - pad) *input_x * input_ch ;
    uint16_t store_size = pad * input_ch;
    memcpy(b_store, b_store_loc, store_size * input_x);
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
        src = input;
    	br_load = br_load_start;
    	b_load = b_load_start;
    	r_load = r_load_start;
        cols_8b = (q7_t*)cols_8b_start; //skip 1 rows
        for (sx = 0; sx < pad; sx++) {
			*cols_8b++ = *br_load;
			br_load += input_ch;
			*cols_8b++ = *br_load;
			br_load += input_ch;
			for (i = 0; i < input_x; i++) {
				*cols_8b++ = *b_load;
				b_load += input_ch;
			}
			cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
        	*cols_8b++ = r_load;
        	r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        br_load_start++;
        b_load_start++;
        r_load_start++;
        input++;
    }
}



tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
    uint16_t store_size = pad * input_ch;
	q7_t* r_load = r_load_start;
	q7_t* b_load = b_load_start;
	q7_t* br_load = br_load_start;
    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
    	b_load = b_load_start;
    	br_load = br_load_start;

        cols_8b = (q7_t*)cols_8b_start;
        for (sx = 0; sx < pad; sx++) {
        	*cols_8b++ = *br_load;
        	br_load += input_ch;
        	*cols_8b++ = *br_load;
        	br_load += input_ch;
        	for(i = 0; i < input_x; i++) {
        		*cols_8b++ = b_load;
        		b_load += input_ch;
        	}
        	cols_8b++;
        }
        src = input;
        for(i = 0; i < input_y; i++){
        	*cols_8b++ = *r_load;
        	r_load += input_ch;
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
            cols_8b++;
        }

        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        b_load_start++;
        br_load_start++;
        input++;
    }
}

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_RStore_FLoad(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value,
				q7_t l_pad, q7_t r_pad, q7_t t_pad, q7_t b_pad,
				q7_t* r_store,
				q7_t* r_load_start, q7_t* b_load_start, q7_t* br_load_start,
				q7_t pad)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;
    uint16_t sx, sy;
    q7_t* r_store_loc = input + (input_x - pad) * input_ch;
    uint16_t store_size = pad * input_ch;
    q7_t* r_load = r_load_start;
	q7_t* b_load = b_load_start;
	q7_t* br_load = br_load_start;

    for(sx = 0; sx < input_y; sx++) {
    	memcpy(r_store, r_store_loc, store_size);
    	r_store_loc += input_ch * input_x;
    	r_store += store_size;
    }


    //Set padding value
    q7_t PAD8 = pad_value;
    /* setup the padding regions for Im2col buffers */
    //top region: 8bit x (input_x + pad_w * 2) x pad_h: unroll by pad value

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	r_load = r_load_start;
    	b_load = b_load_start;
    	br_load = br_load_start;
        cols_8b = (q7_t*)cols_8b_start;
        src = input;
        for (sx = 0; sx < pad; sx++) {
        	*cols_8b++ = *br_load;
        	br_load += input_ch;
        	*cols_8b++ = *br_load;
        	br_load += input_ch;
        	for(i = 0; i < input_x; i++) {
        		*cols_8b++ = *b_load;
        		b_load += input_ch;
        	}
        }
        for(i = 0; i < input_y; i++){
            for(j = 0; j < input_x; j++){
                *cols_8b++ = *src;// + input_offset;
                src += input_ch;
            }
        }

        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch);
        ksrc += 9;
        r_load_start++;
        b_load_start++;
        br_load_start++;
        input++;
    }
}



void depthwise_kernel3x3_stride2_inplace_kernel_CHW(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset)
{
    #define STRIDE 2
    int i, j;
    /* MACs for each output */
    //q31_t ch_bias = bias[0] + biasR[0];
    //DWT->CYCCNT = 0;start = DWT->CYCCNT;
    for (i = 0; i < output_y; i++) {
        for (j = 0; j < output_x / 2; j++) {
            q7_t *cols_8b = cols_8b_iterptr;

            q31_t sum0 = bias[0] ;
            q31_t sum1 = bias[0] ;

            /* computation */
            sum0 += cols_8b[0]*ksrc[0];
            sum1 += cols_8b[2]*ksrc[0];
            sum0 += cols_8b[1]*ksrc[1];
            sum1 += cols_8b[3]*ksrc[1];
            sum0 += cols_8b[2]*ksrc[2];
            sum1 += cols_8b[4]*ksrc[2];
            cols_8b += column_x  + 2;
            sum0 += cols_8b[0]*ksrc[3];
            sum1 += cols_8b[2]*ksrc[3];
            sum0 += cols_8b[1]*ksrc[4];
            sum1 += cols_8b[3]*ksrc[4];
            sum0 += cols_8b[2]*ksrc[5];
            sum1 += cols_8b[4]*ksrc[5];
            cols_8b += column_x  + 2;
            sum0 += cols_8b[0]*ksrc[6];
            sum1 += cols_8b[2]*ksrc[6];
            sum0 += cols_8b[1]*ksrc[7];
            sum1 += cols_8b[3]*ksrc[7];
            sum0 += cols_8b[2]*ksrc[8];
            sum1 += cols_8b[4]*ksrc[8];

            /* requantize */
            sum0 = arm_nn_requantize(sum0  + biasR[0], *multiplier, *shift);
            sum0 += output_offset;
            sum0 = MAX(sum0, activation_min);
            sum0 = MIN(sum0, activation_max);

            output[(i * output_x + j * 2) * channel_offset] = sum0;
            sum1 = arm_nn_requantize(sum1 + biasR[0] , *multiplier, *shift);
            sum1 += output_offset;
            sum1 = MAX(sum1, activation_min);
            sum1 = MIN(sum1, activation_max);
            output[(i * output_x + (j * 2 + 1)) * channel_offset] = sum1;

            cols_8b_iterptr += STRIDE * 2;
        }
        if (output_x & 1) {
            q7_t * cols_8b = cols_8b_iterptr;
            q31_t sum = bias[0] + biasR[0];
            sum += cols_8b[0]*ksrc[0];
            sum += cols_8b[1]*ksrc[1];
            sum += cols_8b[2]*ksrc[2];
            cols_8b += column_x +2;
            sum += cols_8b[0]*ksrc[3];
            sum += cols_8b[1]*ksrc[4];
            sum += cols_8b[2]*ksrc[5];
            cols_8b += column_x +2 ;
            sum += cols_8b[0]*ksrc[6];
            sum += cols_8b[1]*ksrc[7];
            sum += cols_8b[2]*ksrc[8];

            sum = arm_nn_requantize(sum , *multiplier, *shift);
            sum += output_offset;
            sum = MAX(sum, activation_min);
            sum = MIN(sum, activation_max);
            output[(i * output_x + output_x - 1) * channel_offset] = sum;

            cols_8b_iterptr += STRIDE;
        }
        cols_8b_iterptr += 1 * 2 - (column_x & 1);
        cols_8b_iterptr += (STRIDE - 1) * (column_x + 1 * 2);
    }
    //end = DWT->CYCCNT;sprintf(buf, "TOP %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
}
void depthwise_kernel3x3_stride2_inplace_kernel_CHW_PSK(
    const uint16_t output_y, const uint16_t output_x,
    const int32_t* bias, const int32_t* biasR, const q7_t* ksrc, const int32_t* multiplier,
    const int32_t* shift, q7_t* output, const int32_t output_offset,
    const int32_t activation_min, const int32_t activation_max,
    q7_t* cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t* fold_weight);

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_PSK(q7_t* input, const uint16_t input_x, const uint16_t input_y,
    const uint16_t input_ch, const q7_t* kernel, const int32_t* bias, const int32_t* biasR,
    const int32_t* output_shift, const int32_t* output_mult,
    const int32_t output_offset, const int32_t input_offset,
    const int32_t output_activation_min,
    const int32_t output_activation_max, q7_t* output,
    const uint16_t output_x, const uint16_t output_y,
    const uint16_t output_ch, q15_t* runtime_buf, q7_t pad_value, const q7_t* fold_weight)
{

    uint16_t c, i, j;
    q7_t* cols_8b_start = (q7_t*)runtime_buf;
    q7_t* cols_8b = (q7_t*)cols_8b_start;

    const q7_t* src;
    const q7_t* ksrc = kernel;

    for (c = 0; c < input_ch; c++) {
        cols_8b = cols_8b_start;
        src = input;
        for (j = 0; j < input_y; j++) {
            for (i = 0; i < input_x; i++) {
                *cols_8b++ = *src;
                src += input_ch;
            }
        }
        q7_t* inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW_PSK(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out, output_offset, output_activation_min, output_activation_max, cols_8b_start, input_x, input_ch, fold_weight);
        ksrc += 9;
        fold_weight += 40;
        input++;
    }
}
void depthwise_kernel3x3_stride2_inplace_kernel_CHW_PSK(
    const uint16_t output_y, const uint16_t output_x,
    const int32_t* bias, const int32_t* biasR, const q7_t* ksrc, const int32_t* multiplier,
    const int32_t* shift, q7_t* output, const int32_t output_offset,
    const int32_t activation_min, const int32_t activation_max,
    q7_t* cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t* fold_weight)
{
    //DWT->CYCCNT=0; start = DWT->CYCCNT;
    int y, x;
    /*
        q15_t fold_weight[40];
        // fold_weight_[4] fold_weight_[6] Fold
         fold_weight[0] = fold_weight_[0] * ksrc[0] + fold_weight_[4] *ksrc[1] + fold_weight_[6]*ksrc[3] + ksrc[4];
         fold_weight[1] = fold_weight_[4] * ksrc[2] + fold_weight_[6] * ksrc[3] + ksrc[5];
         fold_weight[2]= fold_weight_[4] * ksrc[1] + fold_weight_[6] * ksrc[6] + ksrc[7];
         fold_weight[3]= fold_weight_[4]  * ksrc[2] + fold_weight_[6] * ksrc[6] + ksrc[8];

        // fold_weight_[4] fold_weight_[7] Fold
         fold_weight[4] =fold_weight_[4] *ksrc[0] + ksrc[3] + fold_weight_[7] * ksrc[5];
         fold_weight[5]= fold_weight_[4] *ksrc[1] + fold_weight_[1] * ksrc[2] + ksrc[4] + fold_weight_[7] * ksrc[5];
         fold_weight[6]= fold_weight_[4] *ksrc[0] + ksrc[6] + fold_weight_[7] * ksrc[8];
         fold_weight[7]= fold_weight_[4] *ksrc[1] + ksrc[7] + fold_weight_[7] * ksrc[8];

        // fold_weight_[5] fold_weight_[6] Fold
         fold_weight[8] =fold_weight_[6] * ksrc[0] + ksrc[1] + fold_weight_[5] * ksrc[7];
         fold_weight[9]= fold_weight_[6] * ksrc[0] + ksrc[2] + fold_weight_[5] * ksrc[8];
         fold_weight[10]= fold_weight_[6] * ksrc[3] + ksrc[5] + fold_weight_[5] * ksrc[7] + fold_weight_[2] * ksrc[6];
         fold_weight[11]= fold_weight_[6] * ksrc[3] + ksrc[5] + fold_weight_[5] * ksrc[8];

        // fold_weight_[5] fold_weight_[7] Fold
         fold_weight[12] = ksrc[0] + fold_weight_[7] * ksrc[2] + fold_weight_[5] * ksrc[6];
         fold_weight[13] = ksrc[1] + fold_weight_[7] * ksrc[2] + fold_weight_[5] * ksrc[7];
         fold_weight[14]= ksrc[3] + fold_weight_[7] * ksrc[5] + fold_weight_[5] * ksrc[6];
         fold_weight[15]= ksrc[4] + fold_weight_[7] * ksrc[5] + fold_weight_[5] * ksrc[7] + fold_weight_[3] * ksrc[8];

        // fold_weight_[4] Fold
         fold_weight[16] = ksrc[0] * fold_weight_[4] + ksrc[3];
         fold_weight[17]= ksrc[0]* fold_weight_[4] + ksrc[6];
         fold_weight[18]= ksrc[1]* fold_weight_[4]+ ksrc[4];
         fold_weight[19]= ksrc[1]* fold_weight_[4]+ ksrc[7];
         fold_weight[20]= ksrc[2]* fold_weight_[4]+ ksrc[5];
         fold_weight[21]= ksrc[2]* fold_weight_[4]+ ksrc[8];

        // fold_weight_[5] Fold
         fold_weight[22]= ksrc[0] + fold_weight_[5] * ksrc[6];
         fold_weight[23]= ksrc[3] + fold_weight_[5] * ksrc[6];
         fold_weight[24]= ksrc[1] + fold_weight_[5] * ksrc[7];
         fold_weight[25]= ksrc[4] + ksrc[7] * fold_weight_[5];
         fold_weight[26]= ksrc[2] + ksrc[8] * fold_weight_[5];
         fold_weight[27]= ksrc[5] + ksrc[8] * fold_weight_[5];

        // fold_weight_[6] Fold
         fold_weight[28]= ksrc[1] + ksrc[0] * fold_weight_[6];
         fold_weight[29]= ksrc[2] + ksrc[0] * fold_weight_[6];
         fold_weight[30]= ksrc[4] + ksrc[3]* fold_weight_[6];
         fold_weight[31]= ksrc[5] + ksrc[3]* fold_weight_[6];
         fold_weight[32]= ksrc[7] + ksrc[6]* fold_weight_[6];
         fold_weight[33]= ksrc[8] + ksrc[6]* fold_weight_[6];

        // fold_weight_[7] Fold
         fold_weight[34] = ksrc[1] + ksrc[2]* fold_weight_[7];
         fold_weight[35]= ksrc[2] + ksrc[2]* fold_weight_[7];
         fold_weight[36]= ksrc[3] + ksrc[5]* fold_weight_[7];
         fold_weight[37]= ksrc[4] + ksrc[5]* fold_weight_[7];
         fold_weight[38]= ksrc[6] + ksrc[8]* fold_weight_[7];
         fold_weight[39]= ksrc[7] + ksrc[8]* fold_weight_[7];
         */
    q7_t* cols_8b = cols_8b_iterptr;
    q7_t* cols_left_8b = cols_8b_iterptr;

    q31_t ch_bias = bias[0] + biasR[0];

    q31_t sum = ch_bias;


    sum += cols_8b[0] * fold_weight[24];
    sum += cols_8b[1] * fold_weight[25];
    sum += cols_8b[column_x] * fold_weight[26];
    sum += cols_8b[column_x + 1] * fold_weight[27];

    sum = arm_nn_requantize(sum, *multiplier, *shift);
    sum += output_offset;
    sum = MAX(sum, activation_min);
    sum = MIN(sum, activation_max);
    output[0] = sum;


    cols_8b_iterptr += 1;


    for (x = 1; x < output_x / 2; x++) {
        //DWT->FOLDCNT = 0;
        cols_8b = cols_8b_iterptr;
        q31_t sum0 = ch_bias;
        q31_t sum1 = ch_bias;

        sum0 += cols_8b[0] * fold_weight[0];
        sum1 += cols_8b[2] * fold_weight[0];
        sum0 += cols_8b[1] * fold_weight[1];
        sum1 += cols_8b[3] * fold_weight[1];
        sum0 += cols_8b[2] * fold_weight[2];
        sum1 += cols_8b[4] * fold_weight[2];

        cols_8b += column_x;
        sum0 += cols_8b[0] * fold_weight[3];
        sum1 += cols_8b[2] * fold_weight[3];
        sum0 += cols_8b[1] * fold_weight[4];
        sum1 += cols_8b[3] * fold_weight[4];
        sum0 += cols_8b[2] * fold_weight[5];
        sum1 += cols_8b[4] * fold_weight[5];

        sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
        sum0 += output_offset;
        sum0 = MAX(sum0, activation_min);
        sum0 = MIN(sum0, activation_max);

        sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
        sum1 += output_offset;
        sum1 = MAX(sum1, activation_min);
        sum1 = MIN(sum1, activation_max);
        output[(2 * x) * channel_offset] = sum0;
        output[(2 * x + 1) * channel_offset] = sum1;

        cols_8b_iterptr += 4;

    }

    if (!(output_x & 1)) {
        sum = ch_bias;
        cols_8b = cols_8b_iterptr;

        sum += cols_8b[0] * fold_weight[0];
        sum += cols_8b[1] * fold_weight[1];
        sum += cols_8b[2] * fold_weight[2];

        cols_8b += column_x;
        sum += cols_8b[0] * fold_weight[3];
        sum += cols_8b[1] * fold_weight[4];
        sum += cols_8b[2] * fold_weight[5];


        sum = arm_nn_requantize(sum, *multiplier, *shift);
        sum += output_offset;
        sum = MAX(sum, activation_min);
        sum = MIN(sum, activation_max);
        output[(output_x - 1) * channel_offset] = sum;

        cols_8b_iterptr += 3;
    }

    //end = DWT->CYCCNT;sprintf(buf, "TOP %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
    //DWT->CYCCNT = 0; start = DWT->CYCCNT;

    for (y = 1; y < output_y / 2; y++) {
        q7_t* cols_left_8b2 = cols_left_8b + 2 * column_x;
        q31_t sumL0 = ch_bias;
        q31_t sumL1 = ch_bias;

        sumL0 += cols_left_8b[0] * fold_weight[12];
        sumL0 += cols_left_8b[1] * fold_weight[13];

        sumL0 += cols_left_8b2[0] * fold_weight[16];
        sumL0 += cols_left_8b2[1] * fold_weight[17];

        sumL1 += cols_left_8b2[0] * fold_weight[12];
        sumL1 += cols_left_8b2[1] * fold_weight[13];

        cols_left_8b += column_x;
        cols_left_8b2 += column_x;

        sumL0 += cols_left_8b[0] * fold_weight[14];
        sumL0 += cols_left_8b[1] * fold_weight[15];

        sumL1 += cols_left_8b2[0] * fold_weight[14];
        sumL1 += cols_left_8b2[1] * fold_weight[15];

        cols_left_8b2 += column_x;

        sumL1 += cols_left_8b2[0] * fold_weight[16];
        sumL1 += cols_left_8b2[1] * fold_weight[17];
        cols_left_8b = cols_left_8b2;

        sumL0 = arm_nn_requantize(sumL0, *multiplier, *shift);
        sumL0 += output_offset;
        sumL0 = MAX(sumL0, activation_min);
        sumL0 = MIN(sumL0, activation_max);

        sumL1 = arm_nn_requantize(sumL1, *multiplier, *shift);
        sumL1 += output_offset;
        sumL1 = MAX(sumL1, activation_min);
        sumL1 = MIN(sumL1, activation_max);
        output[(2 * y - 1) * output_x * channel_offset] = sumL0;
        output[2 * y * output_x * channel_offset] = sumL1;
    }
    if (!(output_y & 1)) {
        q31_t sumL = ch_bias;

        sumL += cols_left_8b[0] * fold_weight[12];
        sumL += cols_left_8b[1] * fold_weight[13];

        cols_left_8b += column_x;
        sumL += cols_left_8b[0] * fold_weight[14];
        sumL += cols_left_8b[1] * fold_weight[15];
        cols_left_8b += column_x;

        sumL += cols_left_8b[0] * fold_weight[16];
        sumL += cols_left_8b[1] * fold_weight[17];

        sumL = arm_nn_requantize(sumL, *multiplier, *shift);
        sumL += output_offset;
        sumL = MAX(sumL, activation_min);
        sumL = MIN(sumL, activation_max);
        output[(output_y - 1) * output_x * channel_offset] = sumL;
    }

    //end = DWT->CYCCNT;sprintf(buf, "LEFT  %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;

    //DWT->CYCCNT = 0;start = DWT->CYCCNT;

    for (y = 1; y < output_y; y++) {
        for (x = 1; x < (output_x + (output_x & 1)) / 2; x++) {
            cols_8b = cols_8b_iterptr;
            q31_t sum0 = ch_bias;
            q31_t sum1 = ch_bias;

            sum0 += cols_8b[0] * ksrc[0];
            sum1 += cols_8b[2] * ksrc[0];
            sum0 += cols_8b[1] * ksrc[1];
            sum1 += cols_8b[3] * ksrc[1];
            sum0 += cols_8b[2] * ksrc[2];
            sum1 += cols_8b[4] * ksrc[2];

            cols_8b += column_x;
            sum0 += cols_8b[0] * ksrc[3];
            sum1 += cols_8b[2] * ksrc[3];
            sum0 += cols_8b[1] * ksrc[4];
            sum1 += cols_8b[3] * ksrc[4];
            sum0 += cols_8b[2] * ksrc[5];
            sum1 += cols_8b[4] * ksrc[5];

            cols_8b += column_x;
            sum0 += cols_8b[0] * ksrc[6];
            sum1 += cols_8b[2] * ksrc[6];
            sum0 += cols_8b[1] * ksrc[7];
            sum1 += cols_8b[3] * ksrc[7];
            sum0 += cols_8b[2] * ksrc[8];
            sum1 += cols_8b[4] * ksrc[8];




            sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
            sum0 += output_offset;
            sum0 = MAX(sum0, activation_min);
            sum0 = MIN(sum0, activation_max);

            output[(y * output_x + 2 * x - 1) * channel_offset] = sum0;
            sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
            sum1 += output_offset;
            sum1 = MAX(sum1, activation_min);
            sum1 = MIN(sum1, activation_max);
            output[(y * output_x + 2 * x) * channel_offset] = sum1;

            cols_8b_iterptr += 4;
        }
        if (!(output_x & 1)) {
            q7_t* cols_8b = cols_8b_iterptr;
            q31_t sum = ch_bias;
            sum += cols_8b[0] * ksrc[0];
            sum += cols_8b[1] * ksrc[1];
            sum += cols_8b[2] * ksrc[2];
            cols_8b += column_x;
            sum += cols_8b[0] * ksrc[3];
            sum += cols_8b[1] * ksrc[4];
            sum += cols_8b[2] * ksrc[5];
            cols_8b += column_x;
            sum += cols_8b[0] * ksrc[6];
            sum += cols_8b[1] * ksrc[7];
            sum += cols_8b[2] * ksrc[8];

            sum = arm_nn_requantize(sum, *multiplier, *shift);
            sum += output_offset;
            sum = MAX(sum, activation_min);
            sum = MIN(sum, activation_max);
            output[(y * output_x + output_x - 1) * channel_offset] = sum;
        }
        cols_8b_iterptr += 4 - (column_x & 1);
        cols_8b_iterptr += column_x;
    }

    //end = DWT->CYCCNT;sprintf(buf, "MID %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
}