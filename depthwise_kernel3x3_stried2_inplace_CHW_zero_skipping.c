/* This file is automatically generated */
/* ----------------------------------------------------------------------
 * Project:      TinyEngine
 * Description:  for sparse in-place 3x3 depth-wise convolution (HWC->CHW->HWC)
 * Target ISA:  ARMv7E-M
 * Author: wmchen@mit.edu
 * -------------------------------------------------------------------- */
#include "arm_nnsupportfunctions.h" //TODO: remove this in the future for self-contained
#include "tinyengine_function.h"
#include "stm32f7xx_hal.h"
int start, end;
char buf[100];

void depthwise_kernel3x3_stride2_inplace_kernel_CHW_R(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t *fold_weight);

tinyengine_status depthwise_kernel3x3_stride2_inplace_CHW_R(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value, const q7_t* fold_weight)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
		 cols_8b = cols_8b_start;
		 src = input;
		 for(j = 0; j < input_y; j++) {
			 for(i = 0; i < input_x; i++) {
				 *cols_8b++ = *src;
				 src += input_ch;
			 }
		 }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride2_inplace_kernel_CHW_R(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch, fold_weight);
        ksrc += 9;
        fold_weight += 40;
        input++;
    }
}
void depthwise_kernel3x3_stride2_inplace_kernel_CHW_R(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t *fold_weight)
{
    //DWT->CYCCNT=0; start = DWT->CYCCNT;
    int y, x;
/*
    q15_t fold_weight[40];
    // fold_weight_[4] fold_weight_[6] Fold
     fold_weight[0] = fold_weight_[0] * ksrc[0] + fold_weight_[4] *ksrc[1] + fold_weight_[6]*ksrc[3] + ksrc[4];
     fold_weight[1] = fold_weight_[4] * ksrc[2] + fold_weight_[6] * ksrc[3] + ksrc[5];
     fold_weight[2]= fold_weight_[4] * ksrc[1] + fold_weight_[6] * ksrc[6] + ksrc[7];
     fold_weight[3]= fold_weight_[4]  * ksrc[2] + fold_weight_[6] * ksrc[6] + ksrc[8];

    // fold_weight_[4] fold_weight_[7] Fold
     fold_weight[4] =fold_weight_[4] *ksrc[0] + ksrc[3] + fold_weight_[7] * ksrc[5];
     fold_weight[5]= fold_weight_[4] *ksrc[1] + fold_weight_[1] * ksrc[2] + ksrc[4] + fold_weight_[7] * ksrc[5];
     fold_weight[6]= fold_weight_[4] *ksrc[0] + ksrc[6] + fold_weight_[7] * ksrc[8];
     fold_weight[7]= fold_weight_[4] *ksrc[1] + ksrc[7] + fold_weight_[7] * ksrc[8];

    // fold_weight_[5] fold_weight_[6] Fold
     fold_weight[8] =fold_weight_[6] * ksrc[0] + ksrc[1] + fold_weight_[5] * ksrc[7];
     fold_weight[9]= fold_weight_[6] * ksrc[0] + ksrc[2] + fold_weight_[5] * ksrc[8];
     fold_weight[10]= fold_weight_[6] * ksrc[3] + ksrc[5] + fold_weight_[5] * ksrc[7] + fold_weight_[2] * ksrc[6];
     fold_weight[11]= fold_weight_[6] * ksrc[3] + ksrc[5] + fold_weight_[5] * ksrc[8];

    // fold_weight_[5] fold_weight_[7] Fold
     fold_weight[12] = ksrc[0] + fold_weight_[7] * ksrc[2] + fold_weight_[5] * ksrc[6];
     fold_weight[13] = ksrc[1] + fold_weight_[7] * ksrc[2] + fold_weight_[5] * ksrc[7];
     fold_weight[14]= ksrc[3] + fold_weight_[7] * ksrc[5] + fold_weight_[5] * ksrc[6];
     fold_weight[15]= ksrc[4] + fold_weight_[7] * ksrc[5] + fold_weight_[5] * ksrc[7] + fold_weight_[3] * ksrc[8];

    // fold_weight_[4] Fold
     fold_weight[16] = ksrc[0] * fold_weight_[4] + ksrc[3];
     fold_weight[17]= ksrc[0]* fold_weight_[4] + ksrc[6];
     fold_weight[18]= ksrc[1]* fold_weight_[4]+ ksrc[4];
     fold_weight[19]= ksrc[1]* fold_weight_[4]+ ksrc[7];
     fold_weight[20]= ksrc[2]* fold_weight_[4]+ ksrc[5];
     fold_weight[21]= ksrc[2]* fold_weight_[4]+ ksrc[8];

    // fold_weight_[5] Fold
     fold_weight[22]= ksrc[0] + fold_weight_[5] * ksrc[6];
     fold_weight[23]= ksrc[3] + fold_weight_[5] * ksrc[6];
     fold_weight[24]= ksrc[1] + fold_weight_[5] * ksrc[7];
     fold_weight[25]= ksrc[4] + ksrc[7] * fold_weight_[5];
     fold_weight[26]= ksrc[2] + ksrc[8] * fold_weight_[5];
     fold_weight[27]= ksrc[5] + ksrc[8] * fold_weight_[5];

    // fold_weight_[6] Fold
     fold_weight[28]= ksrc[1] + ksrc[0] * fold_weight_[6];
     fold_weight[29]= ksrc[2] + ksrc[0] * fold_weight_[6];
     fold_weight[30]= ksrc[4] + ksrc[3]* fold_weight_[6];
     fold_weight[31]= ksrc[5] + ksrc[3]* fold_weight_[6];
     fold_weight[32]= ksrc[7] + ksrc[6]* fold_weight_[6];
     fold_weight[33]= ksrc[8] + ksrc[6]* fold_weight_[6];

    // fold_weight_[7] Fold
     fold_weight[34] = ksrc[1] + ksrc[2]* fold_weight_[7];
     fold_weight[35]= ksrc[2] + ksrc[2]* fold_weight_[7];
     fold_weight[36]= ksrc[3] + ksrc[5]* fold_weight_[7];
     fold_weight[37]= ksrc[4] + ksrc[5]* fold_weight_[7];
     fold_weight[38]= ksrc[6] + ksrc[8]* fold_weight_[7];
     fold_weight[39]= ksrc[7] + ksrc[8]* fold_weight_[7];
     */
    q7_t* cols_8b = cols_8b_iterptr;
    q7_t* cols_left_8b = cols_8b_iterptr;

    q31_t ch_bias = bias[0] + biasR[0];

    q31_t sum = ch_bias;


    sum += cols_8b[0] * fold_weight[24];
    sum += cols_8b[1] * fold_weight[25];
    sum += cols_8b[column_x] * fold_weight[26];
    sum += cols_8b[column_x + 1] * fold_weight[27];

    sum = arm_nn_requantize(sum , *multiplier, *shift);
    sum += output_offset;
    sum = MAX(sum, activation_min);
    sum = MIN(sum, activation_max);
    output[0] = sum;


    cols_8b_iterptr += 1 ;


    for (x = 1; x < output_x / 2; x++) {
     	//DWT->FOLDCNT = 0;
    	cols_8b = cols_8b_iterptr;
        q31_t sum0 = ch_bias;
        q31_t sum1 = ch_bias;

        sum0 += cols_8b[0] * fold_weight[0];
        sum1 += cols_8b[2] * fold_weight[0];
        sum0 += cols_8b[1] * fold_weight[1];
        sum1 += cols_8b[3] * fold_weight[1];
        sum0 += cols_8b[2] * fold_weight[2];
        sum1 += cols_8b[4] * fold_weight[2];

        cols_8b += column_x;
        sum0 += cols_8b[0] * fold_weight[3];
        sum1 += cols_8b[2] * fold_weight[3];
        sum0 += cols_8b[1] * fold_weight[4];
        sum1 += cols_8b[3] * fold_weight[4];
        sum0 += cols_8b[2] * fold_weight[5];
        sum1 += cols_8b[4] * fold_weight[5];

        sum0 = arm_nn_requantize(sum0 , *multiplier, *shift);
        sum0 += output_offset;
        sum0 = MAX(sum0, activation_min);
        sum0 = MIN(sum0, activation_max);

        sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
        sum1 += output_offset;
        sum1 = MAX(sum1, activation_min);
        sum1 = MIN(sum1, activation_max);
        output[(2 * x)*channel_offset] = sum0;
        output[(2 * x + 1)*channel_offset] = sum1;

        cols_8b_iterptr += 4;

    }

    if (!(output_x & 1)) {
        sum = ch_bias;
    	cols_8b = cols_8b_iterptr;

    	sum += cols_8b[0] * fold_weight[0];
    	sum += cols_8b[1] * fold_weight[1];
    	sum += cols_8b[2] * fold_weight[2];

    	cols_8b += column_x;
    	sum += cols_8b[0] * fold_weight[3];
    	sum += cols_8b[1] * fold_weight[4];
    	sum += cols_8b[2] * fold_weight[5];


        sum = arm_nn_requantize(sum, *multiplier, *shift);
        sum += output_offset;
        sum = MAX(sum, activation_min);
        sum  = MIN(sum, activation_max);
        output[(output_x - 1) * channel_offset] = sum;

        cols_8b_iterptr += 3;
    }

    //end = DWT->CYCCNT;sprintf(buf, "TOP %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
    //DWT->CYCCNT = 0; start = DWT->CYCCNT;

    for (y = 1; y < output_y / 2; y++) {
    	  q7_t* cols_left_8b2 = cols_left_8b + 2* column_x;
          q31_t sumL0 = ch_bias;
          q31_t sumL1 = ch_bias;

          sumL0 += cols_left_8b[0] * fold_weight[12];
          sumL0 += cols_left_8b[1] * fold_weight[13];

          sumL0 += cols_left_8b2[0] * fold_weight[16];
          sumL0 += cols_left_8b2[1] * fold_weight[17];

          sumL1 += cols_left_8b2[0] * fold_weight[12];
          sumL1 += cols_left_8b2[1] * fold_weight[13];

          cols_left_8b += column_x;
          cols_left_8b2 += column_x;

          sumL0 += cols_left_8b[0] * fold_weight[14];
          sumL0 += cols_left_8b[1] * fold_weight[15];

          sumL1 += cols_left_8b2[0] * fold_weight[14];
          sumL1 += cols_left_8b2[1] * fold_weight[15];

          cols_left_8b2 += column_x;

          sumL1 += cols_left_8b2[0] * fold_weight[16];
          sumL1 += cols_left_8b2[1] * fold_weight[17];
          cols_left_8b = cols_left_8b2;

          sumL0 = arm_nn_requantize(sumL0, *multiplier, *shift);
          sumL0 += output_offset;
          sumL0 = MAX(sumL0, activation_min);
          sumL0 = MIN(sumL0, activation_max);

          sumL1 = arm_nn_requantize(sumL1, *multiplier, *shift);
          sumL1 += output_offset;
          sumL1 = MAX(sumL1, activation_min);
          sumL1 = MIN(sumL1, activation_max);
          output[(2 * y - 1) * output_x * channel_offset] = sumL0;
          output[2 * y * output_x * channel_offset] = sumL1;
    }
    if (!(output_y & 1)) {
        q31_t sumL = ch_bias;

        sumL += cols_left_8b[0] * fold_weight[12];
        sumL += cols_left_8b[1] * fold_weight[13];

        cols_left_8b += column_x;
        sumL += cols_left_8b[0] * fold_weight[14];
        sumL += cols_left_8b[1] * fold_weight[15];
        cols_left_8b += column_x;

        sumL += cols_left_8b[0] * fold_weight[16];
        sumL += cols_left_8b[1] * fold_weight[17];

        sumL = arm_nn_requantize(sumL, *multiplier, *shift);
        sumL += output_offset;
        sumL = MAX(sumL, activation_min);
        sumL  = MIN(sumL, activation_max);
        output[(output_y- 1) * output_x * channel_offset] = sumL;
    }

    //end = DWT->CYCCNT;sprintf(buf, "LEFT  %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;

    //DWT->CYCCNT = 0;start = DWT->CYCCNT;

    for (y = 1; y < output_y; y++) {
        for (x = 1; x < (output_x + (output_x & 1))/2; x++) {
            cols_8b = cols_8b_iterptr;
            q31_t sum0 = ch_bias;
            q31_t sum1 = ch_bias;

            sum0 += cols_8b[0] * ksrc[0];
            sum1 += cols_8b[2] * ksrc[0];
            sum0 += cols_8b[1] * ksrc[1];
            sum1 += cols_8b[3] * ksrc[1];
            sum0 += cols_8b[2] * ksrc[2];
            sum1 += cols_8b[4] * ksrc[2];

            cols_8b += column_x;
            sum0 += cols_8b[0] * ksrc[3];
            sum1 += cols_8b[2] * ksrc[3];
            sum0 += cols_8b[1] * ksrc[4];
            sum1 += cols_8b[3] * ksrc[4];
            sum0 += cols_8b[2] * ksrc[5];
            sum1 += cols_8b[4] * ksrc[5];

            cols_8b += column_x;
            sum0 += cols_8b[0] * ksrc[6];
            sum1 += cols_8b[2] * ksrc[6];
            sum0 += cols_8b[1] * ksrc[7];
            sum1 += cols_8b[3] * ksrc[7];
            sum0 += cols_8b[2] * ksrc[8];
            sum1 += cols_8b[4] * ksrc[8];




            sum0 = arm_nn_requantize(sum0 , *multiplier, *shift);
            sum0 += output_offset;
            sum0 = MAX(sum0, activation_min);
            sum0 = MIN(sum0, activation_max);

            output[(y * output_x + 2 * x - 1) * channel_offset] = sum0;
            sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
            sum1 += output_offset;
            sum1 = MAX(sum1, activation_min);
            sum1 = MIN(sum1, activation_max);
            output[(y * output_x + 2 * x) * channel_offset] = sum1;

            cols_8b_iterptr += 4;
        }
        if (!(output_x & 1)) {
            q7_t * cols_8b = cols_8b_iterptr;
            q31_t sum = ch_bias;
            sum += cols_8b[0]*ksrc[0];
            sum += cols_8b[1]*ksrc[1];
            sum += cols_8b[2]*ksrc[2];
            cols_8b += column_x;
            sum += cols_8b[0]*ksrc[3];
            sum += cols_8b[1]*ksrc[4];
            sum += cols_8b[2]*ksrc[5];
            cols_8b += column_x;
            sum += cols_8b[0]*ksrc[6];
            sum += cols_8b[1]*ksrc[7];
            sum += cols_8b[2]*ksrc[8];

            sum = arm_nn_requantize(sum, *multiplier, *shift);
            sum += output_offset;
            sum = MAX(sum, activation_min);
            sum = MIN(sum, activation_max);
            output[(y * output_x + output_x -  1) * channel_offset] = sum;
        }
        cols_8b_iterptr += 4 - (column_x & 1);
        cols_8b_iterptr += column_x;
    }

    //end = DWT->CYCCNT;sprintf(buf, "MID %d\r\n", end - start);printLog(buf);    DWT->CYCCNT = 0;start = DWT->CYCCNT;
}
