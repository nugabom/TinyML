 /* This file is automatically generated */
/* ----------------------------------------------------------------------
 * Project:      TinyEngine
 * Description:  for sparse in-place 3x3 depth-wise convolution (HWC->CHW->HWC)
 * Target ISA:  ARMv7E-M
 * Author: wmchen@mit.edu
 * -------------------------------------------------------------------- */
#include "arm_nnsupportfunctions.h" //TODO: remove this in the future for self-contained
#include "tinyengine_function.h"
static char buf[100];
#include "stm32f7xx_hal.h"
int start, end, time;
void depthwise_kernel3x3_stride1_inplace_kernel_CHW_mean_2C(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t* fold_weight);
tinyengine_status depthwise_kernel3x3_stride1_inplace_CHW_mean_2C(q7_t *input, const uint16_t input_x, const uint16_t input_y,
                const uint16_t input_ch, const q7_t *kernel, const int32_t *bias, const int32_t *biasR,
                const int32_t *output_shift, const int32_t *output_mult,
                const int32_t output_offset, const int32_t input_offset,
                const int32_t output_activation_min,
                const int32_t output_activation_max, q7_t *output,
                const uint16_t output_x, const uint16_t output_y,
                const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value, const q7_t* fold_weight)
{

    uint16_t c,i,j;
    q7_t *cols_8b_start = (q7_t *)runtime_buf;
    q7_t* cols_8b = (q7_t* )cols_8b_start;

    const q7_t *src;
    const q7_t *ksrc = kernel;

    for (c = 0; c < input_ch; c++){
    	 cols_8b = cols_8b_start;
    	 src = input;
    	 for(j = 0; j < input_y; j++) {
    		 for(i = 0; i < input_x; i++) {
    			 *cols_8b++ = *src;
    			 src += input_ch;
    		 }
    	 }
        q7_t *inplace_out = input;
        depthwise_kernel3x3_stride1_inplace_kernel_CHW_mean_2C(output_y, output_x, bias++, biasR++, ksrc, output_mult++, output_shift++, inplace_out,output_offset,output_activation_min, output_activation_max,cols_8b_start, input_x, input_ch, (const q7_t*)fold_weight);
        ksrc += 9;
        fold_weight += 40;
        input++;
    }

}
void depthwise_kernel3x3_stride1_inplace_kernel_CHW_mean_2C(
        const uint16_t output_y, const uint16_t output_x,
        const int32_t *bias, const int32_t *biasR, const q7_t *ksrc, const int32_t *multiplier,
        const int32_t *shift, q7_t *output, const int32_t output_offset,
        const int32_t activation_min, const int32_t activation_max,
        q7_t *cols_8b_iterptr, const uint16_t column_x, int channel_offset, const q7_t* fold_weight)
{
    #define STRIDE 1
#define STRIDE 1
    int y = 0;
    int x = 0;

    q7_t* cols_8b_left_start = cols_8b_iterptr;
    q7_t* cols_8b_start = cols_8b_iterptr;
    q31_t ch_bias= bias[0] + biasR[0];
    q7_t* cols_8b_bot_iterptr = cols_8b_start + column_x * (column_x - 2);

    q7_t* cols_8b_left = cols_8b_start;
    q7_t* cols_8b_right = cols_8b_start + column_x - 2;
    q31_t sum0 = ch_bias;
    q31_t sum1 = ch_bias;

    sum0 += cols_8b_left[0] * fold_weight[0];
    sum0 += cols_8b_left[1] * fold_weight[1];
    sum0 += cols_8b_right[2] * fold_weight[2];
    sum0 += cols_8b_right[3] * fold_weight[3];
    sum1 += cols_8b_right[0] * fold_weight[4];
    sum1 += cols_8b_right[1] * fold_weight[5];


    sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
    sum0 += output_offset;
    sum0 = MAX(sum0, activation_min);
    sum0 = MIN(sum0, activation_max);
    cols_8b_right += column_x;
    sum1 += cols_8b_right[0] * fold_weight[6];
    sum1 += cols_8b_right[1] * fold_weight[7];


    sum0 = ch_bias;
    sum1 = ch_bias;
    sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
    sum1 += output_offset;
    sum1 = MAX(sum1, activation_min);
    sum1 = MIN(sum1, activation_max);
    output[0] = sum0;
    output[(output_x - 1) * channel_offset] = sum1;

    cols_8b_left = cols_8b_bot_iterptr;
    cols_8b_right = cols_8b_bot_iterptr + column_x - 2;

    sum0 += cols_8b_left[0] * fold_weight[8];
    sum0 += cols_8b_left[1] * fold_weight[9];
    sum0 += cols_8b_right[2] * fold_weight[10];
    sum0 += cols_8b_right[3] * fold_weight[11] ;
    sum1 += cols_8b_right[0] * fold_weight[12];
    sum1 += cols_8b_right[1] * fold_weight[13];

    sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
    sum0 += output_offset;
    sum0 = MAX(sum0, activation_min);
    sum0 = MIN(sum0, activation_max);

    cols_8b_right += column_x;
    sum1 += cols_8b_right[0] * fold_weight[14];
    sum1 += cols_8b_right[1] * fold_weight[15];



    sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
    sum1 += output_offset;
    sum1 = MAX(sum1, activation_min);
    sum1 = MIN(sum1, activation_max);
    output[((output_y - 1) * output_x) * channel_offset] = sum0;
    output[((output_y - 1) * output_x + output_x - 1) * channel_offset] = sum1;



    for (x = 1; x < output_x / 2; ++x) {
          q7_t* cols_8b = cols_8b_iterptr;
          q7_t* cols_8b_bot = cols_8b_bot_iterptr;
          q31_t sumB0 = ch_bias;
          q31_t sumB1 = ch_bias;
          q31_t sum0 = ch_bias;
          q31_t sum1 = ch_bias;

          sumB0 += cols_8b_bot[0] * fold_weight[22];
          sumB1 += cols_8b_bot[1] * fold_weight[22];
          sumB0 += cols_8b_bot[1] * fold_weight[23];
          sumB1 += cols_8b_bot[2] * fold_weight[23];
          sumB0 += cols_8b_bot[2] * fold_weight[24];
          sumB1 += cols_8b_bot[3] * fold_weight[24];


          cols_8b_bot += column_x;

          sumB0 += cols_8b_bot[0] * fold_weight[25];
          sumB1 += cols_8b_bot[1] * fold_weight[25];
          sumB0 += cols_8b_bot[1] * fold_weight[26];
          sumB1 += cols_8b_bot[2] * fold_weight[26];
          sumB0 += cols_8b_bot[2] * fold_weight[27];
          sumB1 += cols_8b_bot[3] * fold_weight[27];

          cols_8b_iterptr += 1;
          cols_8b_bot_iterptr += 1;

          sumB0 = arm_nn_requantize(sumB0, *multiplier, *shift);
          sumB0 += output_offset;
          sumB0 = MAX(sumB0, activation_min);
          sumB0 = MIN(sumB0, activation_max);
          sumB1 = arm_nn_requantize(sumB1, *multiplier, *shift);
          sumB1 += output_offset;
          sumB1 = MAX(sumB1, activation_min);
          sumB1 = MIN(sumB1, activation_max);
          output[((output_y - 1) * output_x + x * 2 - 1) * channel_offset] = sumB0;
          output[((output_y - 1) * output_x + x * 2) * channel_offset] = sumB1;

          cols_8b_iterptr += 1;
          sum0 += cols_8b[0] * fold_weight[16];
          sum1 += cols_8b[1] * fold_weight[16];
          sum0 += cols_8b[1] * fold_weight[17];
          sum1 += cols_8b[2] * fold_weight[17];
          sum0 += cols_8b[2] * fold_weight[18];
          sum1 += cols_8b[3] * fold_weight[18];
          //cols_8b_iterptr += 1;
          cols_8b += column_x;
          sum0 += cols_8b[0] * fold_weight[19];
          sum1 += cols_8b[1] * fold_weight[19];
          sum0 += cols_8b[1] * fold_weight[20];
          sum1 += cols_8b[2] * fold_weight[20];
          sum0 += cols_8b[2] * fold_weight[21];
          sum1 += cols_8b[3] * fold_weight[21];


          sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
          sum0 += output_offset;
          sum0 = MAX(sum0, activation_min);
          sum0 = MIN(sum0, activation_max);
          sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
          sum1 += output_offset;
          sum1 = MAX(sum1, activation_min);
          sum1 = MIN(sum1, activation_max);
          output[(2 * x - 1) * channel_offset] = sum0;
          output[(2 * x) * channel_offset] = sum1;


          cols_8b_bot_iterptr += 1;

      }
      if (output_x & 1) {
          q7_t* cols_8b = cols_8b_iterptr;
          q7_t* cols_8b_bot = cols_8b_bot_iterptr;
          q31_t sum = ch_bias;
          q31_t sumB = ch_bias;
          sum += cols_8b[0] * fold_weight[16];
          sum += cols_8b[1] * fold_weight[17];
          sum += cols_8b[2] * fold_weight[18];
          cols_8b += column_x;
          sum += cols_8b[0] * fold_weight[19];
          sum += cols_8b[1] * fold_weight[20];
          sum += cols_8b[2] * fold_weight[21];
          sumB += cols_8b_bot[0] * fold_weight[22];
          sumB += cols_8b_bot[1] * fold_weight[23];
          sumB += cols_8b_bot[2] * fold_weight[24];
          cols_8b_bot += column_x;
          sumB += cols_8b_bot[0] * fold_weight[25];
          sumB += cols_8b_bot[1] * fold_weight[26];
          sumB += cols_8b_bot[2] * fold_weight[27];
          sum = arm_nn_requantize(sum, *multiplier, *shift);
          sum += output_offset;
          sum = MAX(sum, activation_min);
          sum = MIN(sum, activation_max);
          cols_8b_iterptr += 1;
          sumB = arm_nn_requantize(sumB, *multiplier, *shift);
          sumB += output_offset;
          sumB = MAX(sumB, activation_min);
          sumB = MIN(sumB, activation_max);
          output[(output_x - 2) * channel_offset] = sum;
          output[((output_y - 1) * output_x - 2) * channel_offset] = sumB;
          cols_8b_bot_iterptr += 1;
      }

    q7_t* cols_8b_left_iterptr = cols_8b_left_start;
    q7_t* cols_8b_right_iterptr = cols_8b_iterptr;

      for (y = 1; y < output_y / 2; ++y) {
        q7_t* cols_left_8b = cols_8b_left_iterptr;
          q7_t* cols_right_8b = cols_8b_right_iterptr;
          q31_t sumL0 = ch_bias;
          q31_t sumL1 = ch_bias;
          q31_t sumR0 = ch_bias;
          q31_t sumR1 = ch_bias;
          //DWT->FOLDCNT = 0;
          sumL0 += cols_left_8b[0] * fold_weight[28];
          sumL0 += cols_left_8b[1] * fold_weight[29];


          cols_left_8b += column_x;
          cols_right_8b += column_x;

          sumL0 += cols_left_8b[0] * fold_weight[30];
          sumL0 += cols_left_8b[1] * fold_weight[31];



          sumL1 += cols_left_8b[0] * fold_weight[28];
          sumL1 += cols_left_8b[1] * fold_weight[29];
          sumL1 += cols_right_8b[2] * fold_weight[30];
          sumL1 += cols_right_8b[3] * fold_weight[31];

          sumR0 += cols_left_8b[-2] * fold_weight[34];
          sumR0 += cols_left_8b[-1] * fold_weight[35];

          sumR1 += cols_right_8b[0] * fold_weight[34];
          sumR1 += cols_right_8b[1] * fold_weight[35];

          sumL0 += cols_right_8b[2] * fold_weight[32];
          sumL0 += cols_right_8b[3] * fold_weight[33];
          cols_left_8b += 2 * column_x;
          sumL1 += cols_left_8b[0] * fold_weight[32];
          sumL1 += cols_left_8b[1] * fold_weight[33];


          cols_8b_left_iterptr += column_x;
          cols_8b_right_iterptr += column_x;

          sumL0 = arm_nn_requantize(sumL0, *multiplier, *shift);
          sumL0 += output_offset;
          sumL0 = MAX(sumL0, activation_min);
          sumL0 = MIN(sumL0, activation_max);
          sumL1 = arm_nn_requantize(sumL1, *multiplier, *shift);
          sumL1 += output_offset;
          sumL1 = MAX(sumL1, activation_min);
          sumL1 = MIN(sumL1, activation_max);
          output[(2 * y - 1) * output_x * channel_offset] = sumL0;
          output[2 * y * output_x * channel_offset] = sumL1;

          sumR0 += cols_right_8b[0] * fold_weight[36];
          sumR0 += cols_right_8b[1] * fold_weight[37];


          cols_right_8b += 2 * column_x;

          sumR1 += cols_left_8b[-2] * fold_weight[36];
          sumR1 += cols_left_8b[-1] * fold_weight[37];


          sumR0 += cols_left_8b[-2] * fold_weight[38];
          sumR0 += cols_left_8b[-1] * fold_weight[39];


          sumR1 += cols_right_8b[0] * fold_weight[38];
          sumR1 += cols_right_8b[1] * fold_weight[39];

          sumR0 = arm_nn_requantize(sumR0, *multiplier, *shift);
          sumR0 += output_offset;
          sumR0 = MAX(sumR0, activation_min);
          sumR0 = MIN(sumR0, activation_max);






          sumR1 = arm_nn_requantize(sumR1, *multiplier, *shift);
          sumR1 += output_offset;
          sumR1 = MAX(sumR1, activation_min);
          sumR1 = MIN(sumR1, activation_max);
          output[((2 * y - 1) * output_x + output_x - 1) * channel_offset] = sumR0;
          output[((2 * y) * output_x + output_x - 1) * channel_offset] = sumR1;

          cols_8b_left_iterptr += column_x;
          cols_8b_right_iterptr += column_x;
      }
     if(output_y &1) {
         q7_t* cols_right_8b = cols_8b_right_iterptr;
         q31_t sumR = ch_bias;
         q31_t sumL = ch_bias;

         sumR += cols_right_8b[0] * fold_weight[34];
         sumR += cols_right_8b[1] * fold_weight[35];

         sumL += cols_right_8b[2] * fold_weight[30];
         sumL += cols_right_8b[3] * fold_weight[31];
         cols_right_8b += column_x;

         sumR += cols_right_8b[0] * fold_weight[36];
         sumR += cols_right_8b[1] * fold_weight[37];

         sumL += cols_right_8b[2] * fold_weight[32];
         sumL += cols_right_8b[3] * fold_weight[33];

         //cols_right_8b += column_x;
         sumR += cols_right_8b[column_x] * fold_weight[38];
         sumR += cols_right_8b[column_x + 1] * fold_weight[39];

         sumL += cols_8b_right_iterptr[-column_x + 2] * fold_weight[28];
         sumL += cols_8b_right_iterptr[-column_x + 3] * fold_weight[29];


         sumL = arm_nn_requantize(sumL, *multiplier, *shift);
         sumL += output_offset;
         sumL = MAX(sumL, activation_min);
         sumL = MIN(sumL, activation_max);

         sumR = arm_nn_requantize(sumR, *multiplier, *shift);
         sumR += output_offset;
         sumR = MAX(sumR, activation_min);
         sumR = MIN(sumR, activation_max);
         output[(output_y* output_x - 1) * channel_offset] = sumL;
         output[((output_y - 1) * output_x + output_x - 1) * channel_offset] = sumR;




     }
     cols_8b_iterptr = cols_8b_start;
     for (y = 1; y < output_y - 1; y++) {
         for (x = 1; x < output_x / 2; x++) {
             q7_t* cols_8b = cols_8b_iterptr;
             q31_t sum0 = ch_bias;
             q31_t sum1 = ch_bias;

             sum0 += cols_8b[0] * ksrc[0];
             sum1 += cols_8b[1] * ksrc[0];
             sum0 += cols_8b[1] * ksrc[1];
             sum1 += cols_8b[2] * ksrc[1];
             sum0 += cols_8b[2] * ksrc[2];
             sum1 += cols_8b[3] * ksrc[2];

             cols_8b += column_x;
             sum0 += cols_8b[0] * ksrc[3];
             sum1 += cols_8b[1] * ksrc[3];
             sum0 += cols_8b[1] * ksrc[4];
             sum1 += cols_8b[2] * ksrc[4];
             sum0 += cols_8b[2] * ksrc[5];
             sum1 += cols_8b[3] * ksrc[5];

             cols_8b += column_x;
             sum0 += cols_8b[0] * ksrc[6];
             sum1 += cols_8b[1] * ksrc[6];
             sum0 += cols_8b[1] * ksrc[7];
             sum1 += cols_8b[2] * ksrc[7];
             sum0 += cols_8b[2] * ksrc[8];
             sum1 += cols_8b[3] * ksrc[8];



             sum0 = arm_nn_requantize(sum0, *multiplier, *shift);
             sum0 += output_offset;
             sum0 = MAX(sum0, activation_min);
             sum0 = MIN(sum0, activation_max);
             sum1 = arm_nn_requantize(sum1, *multiplier, *shift);
             sum1 += output_offset;
             sum1 = MAX(sum1, activation_min);
             sum1 = MIN(sum1, activation_max);


             output[(y * output_x + x * 2 - 1) * channel_offset] = sum0;
             output[(y * output_x + x * 2) * channel_offset] = sum1;

             cols_8b_iterptr += 1 * 2;
         }
         if (output_x & 1) {
             q7_t* cols_8b = cols_8b_iterptr;
             q31_t sum = ch_bias;
             sum += cols_8b[0] * ksrc[0];
             sum += cols_8b[1] * ksrc[1];
             sum += cols_8b[2] * ksrc[2];
             cols_8b += column_x;
             sum += cols_8b[0] * ksrc[3];
             sum += cols_8b[1] * ksrc[4];
             sum += cols_8b[2] * ksrc[5];

             cols_8b += column_x;
             sum += cols_8b[0] * ksrc[6];
             sum += cols_8b[1] * ksrc[7];
             sum += cols_8b[2] * ksrc[8];
             sum = arm_nn_requantize(sum, *multiplier, *shift);
             sum += output_offset;
             sum = MAX(sum, activation_min);
             sum = MIN(sum, activation_max);
             output[(y * output_x + output_x - 2) * channel_offset] = sum;

             cols_8b_iterptr += 1;
         }
         cols_8b_iterptr += 2;
     }

}
